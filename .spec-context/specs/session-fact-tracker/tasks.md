# Tasks: Session Fact Tracker

- [x] 1. Create SessionFact type and ISessionFactStore interface
  - File: src/core/session/types.ts
  - Define `SessionFact` value object, `SessionFactTag` union type, `ISessionFactStore` interface, `IFactExtractor` interface, `IFactRetriever` interface, `FactQuery` type
  - All types are readonly/immutable. `SessionFact.id` is deterministic hash of (subject, relation, object)
  - Purpose: Establish type contracts for the entire session fact tracking system
  - _Leverage: src/core/llm/types.ts (StateSnapshotFact pattern), src/tools/workflow/dispatch-contract-schemas.ts (ImplementerResult, ReviewerResult)_
  - _Requirements: 1.3, 1.4, 2.2, 3.1_
  - _Prompt: Implement the task for spec session-fact-tracker, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in type systems and immutable data structures | Task: Create all type definitions for the session fact tracker following the design document. Define SessionFact as a readonly interface with fields: id (string), subject (string), relation (string), object (string), tags (ReadonlyArray<SessionFactTag>), validFrom (Date), validTo (Date | undefined), sourceTaskId (string), sourceRole ('implementer' | 'reviewer'), confidence (number). Define SessionFactTag as union type: 'file_change' | 'convention' | 'decision' | 'error' | 'dependency' | 'test'. Define ISessionFactStore with methods: add(facts: SessionFact[]): void, invalidate(subject: string, relation: string): void, getValid(): SessionFact[], getValidByTags(tags: SessionFactTag[]): SessionFact[], count(): number, compact(maxFacts: number): void. Define IFactExtractor with methods: extractFromImplementer(result: ImplementerResult, taskId: string): SessionFact[], extractFromReviewer(result: ReviewerResult, taskId: string): SessionFact[]. Define IFactRetriever with method: retrieve(query: FactQuery): SessionFact[]. Define FactQuery with fields: taskDescription (string), taskId (string), tags (SessionFactTag[] | undefined), maxFacts (number), maxTokens (number). Add a createFactId(subject: string, relation: string, object: string): string helper that generates deterministic SHA-256 based ID truncated to 16 hex chars. | Restrictions: Do not import any external dependencies. All interfaces must be in a single file. Do not implement concrete classes here — only types and interfaces. The createFactId helper is the only function in this file. | Success: All types compile without errors. createFactId produces consistent IDs for same inputs. Types are exported and importable from src/core/session/types.ts. | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 2. Implement InMemorySessionFactStore
  - File: src/core/session/session-fact-store.ts
  - Implement `ISessionFactStore` with `Map<string, SessionFact>` backing store and subject index `Map<string, Set<string>>`
  - Auto-invalidate existing facts with same subject+relation on `add()`. `compact()` removes oldest invalidated first, then oldest valid.
  - Purpose: In-memory session-scoped fact persistence with temporal invalidation
  - _Leverage: src/core/session/types.ts (task 1), src/tools/workflow/dispatch-runtime.ts (mergeFacts pattern at line 1317)_
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 1.4_
  - _Prompt: Implement the task for spec session-fact-tracker, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in in-memory data structures and state management | Task: Implement InMemorySessionFactStore class that implements ISessionFactStore from src/core/session/types.ts. Internal state: facts Map<string, SessionFact> keyed by fact.id, and subjectIndex Map<string, Set<string>> mapping subject to fact IDs for fast invalidation lookups. add(): for each incoming fact, check if a valid fact with same subject+relation exists — if so, set validTo on the old fact (create new SessionFact with validTo=new Date() since they're immutable, replace in map), then add the new fact. Update subjectIndex. invalidate(subject, relation): find all valid facts matching subject+relation, set validTo on each. getValid(): return all facts where validTo is undefined. getValidByTags(tags): return valid facts where at least one tag matches. count(): return count of valid (non-invalidated) facts. compact(maxFacts): if valid count exceeds maxFacts, first remove all invalidated facts from the map, then if still over limit, sort valid facts by validFrom ascending and remove oldest until at maxFacts. | Restrictions: No external dependencies. Immutable SessionFact objects — create new objects when setting validTo, never mutate. No async — all methods are synchronous. | Success: All ISessionFactStore methods work correctly. Auto-invalidation on add() works. compact() respects the priority order (invalidated first, then oldest valid). Subject index stays consistent after all operations. | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 3. Implement RuleBasedFactExtractor
  - File: src/core/session/fact-extractor.ts
  - Implement `IFactExtractor` with deterministic rule-based parsing of ImplementerResult and ReviewerResult fields
  - Each extraction rule is a pure function registered in an array. New rules added by appending (OCP).
  - Purpose: Zero-cost fact extraction from structured dispatch results
  - _Leverage: src/core/session/types.ts (task 1), src/tools/workflow/dispatch-contract-schemas.ts (ImplementerResult, ReviewerResult types)_
  - _Requirements: 1.1, 1.2, 1.3, 5.1, 5.2, 5.3, 5.4_
  - _Prompt: Implement the task for spec session-fact-tracker, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in data transformation and parsing | Task: Implement RuleBasedFactExtractor class that implements IFactExtractor from src/core/session/types.ts. Import ImplementerResult and ReviewerResult from src/tools/workflow/dispatch-contract-schemas.ts. Define ExtractionRule type as (result: unknown, taskId: string) => SessionFact[]. Maintain a rules array for implementer and reviewer separately. Implementer rules: (1) extract status fact: subject=task:{taskId}, relation=completed_with, object=result.status, tag=decision. (2) extract summary fact: subject=task:{taskId}, relation=summary, object=clipText(result.summary, 120), tag=decision. (3) extract files_modified: for each file in result.files_modified (if present and is array), subject=file path, relation=modified_by, object=task:{taskId}, tag=file_change. (4) extract follow_up_actions: for each action in result.follow_up_actions (if present and is array), subject=task:{taskId}, relation=requires, object=clipText(action, 120), tag=dependency. Reviewer rules: (1) extract assessment: subject=task:{taskId}, relation=reviewed_as, object=result.assessment, tag=decision. (2) extract issues: for each issue in result.issues (if present and is array), subject=issue.file or task:{taskId}, relation=issue, object=clipText(issue.message, 120), tag=error. (3) extract required_fixes: for each fix in result.required_fixes (if present and is array), subject=task:{taskId}, relation=must_fix, object=clipText(fix, 120), tag=convention. Each rule must be wrapped in try/catch — if a rule fails, log warning and skip, other rules still run. Use createFactId from types.ts. All facts get confidence=1, sourceRole from the method name, validFrom=new Date(). | Restrictions: No LLM calls. No I/O. No external dependencies. clipText is a local helper: if string > maxChars, truncate and append "...". Every rule must be individually try/catch guarded. | Success: extractFromImplementer parses all fields correctly from a valid ImplementerResult. extractFromReviewer parses all fields correctly from a valid ReviewerResult. Missing optional fields (files_modified, follow_up_actions, required_fixes) produce zero facts, not errors. Malformed individual fields skip gracefully. | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 4. Implement KeywordFactRetriever
  - File: src/core/session/fact-retriever.ts
  - Implement `IFactRetriever` with tag filtering, keyword overlap scoring, self-exclusion, and token budget truncation
  - Purpose: Retrieve most relevant facts for a given task context within token budget
  - _Leverage: src/core/session/types.ts (task 1), src/core/session/session-fact-store.ts (task 2)_
  - _Requirements: 3.1, 3.2, 3.3, 3.4_
  - _Prompt: Implement the task for spec session-fact-tracker, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in information retrieval and scoring algorithms | Task: Implement KeywordFactRetriever class that implements IFactRetriever from src/core/session/types.ts. Constructor takes ISessionFactStore. retrieve(query: FactQuery) method: (1) Get valid facts from store — if query.tags provided, use getValidByTags, else use getValid. (2) Exclude self: filter out facts where sourceTaskId === query.taskId. (3) Score each fact by keyword overlap: tokenize query.taskDescription into lowercase words split on /[\s/\-_.,:;()[\]{}]+/, remove stopwords (hardcoded set: a, an, the, is, are, was, were, be, been, being, have, has, had, do, does, did, will, would, shall, should, may, might, can, could, of, in, to, for, with, on, at, by, from, as, or, and, but, not, no, this, that, it, its). Tokenize each fact's subject+relation+object the same way. Score = count of matching words / total query words. (4) Sort by score descending, then validFrom descending for ties. (5) Take top query.maxFacts. (6) Estimate tokens: for each fact, tokens = Math.ceil((fact.subject + fact.relation + fact.object).length / 4). Accumulate until exceeding query.maxTokens, truncate there. Return the kept facts. | Restrictions: No external dependencies. No LLM calls. No I/O. Stopword list is a const Set<string>. Return empty array if store is empty or no facts pass filters. | Success: Retrieval correctly filters by tags. Self-exclusion works. Keyword scoring ranks more-relevant facts higher. Token budget truncation works. Empty store returns empty array. Query with no keyword overlap returns facts sorted by recency. | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 5. Implement formatSessionFacts and barrel export
  - File: src/core/session/format.ts, src/core/session/index.ts
  - Implement `formatSessionFacts(facts: SessionFact[]): string` that renders facts as prompt-injectable text
  - Create barrel export `src/core/session/index.ts` re-exporting all public types and classes
  - Purpose: Prompt formatting and clean module boundary
  - _Leverage: src/core/session/types.ts (task 1)_
  - _Requirements: 4.1, 4.3, 4.4_
  - _Prompt: Implement the task for spec session-fact-tracker, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in string formatting and module organization | Task: (A) Create src/core/session/format.ts with function formatSessionFacts(facts: SessionFact[]): string. If facts is empty, return empty string "". Otherwise, build a string starting with "[Session Context]" header line, followed by one line per fact formatted as: "- {subject} {relation} {object} [task:{sourceTaskId}]". Each line must be max 120 chars — if longer, truncate the object portion and append "...". Tags are not included in the formatted output (they're used for filtering, not display). (B) Create src/core/session/index.ts barrel export that re-exports: all types from types.ts, InMemorySessionFactStore from session-fact-store.ts, RuleBasedFactExtractor from fact-extractor.ts, KeywordFactRetriever from fact-retriever.ts, formatSessionFacts from format.ts. | Restrictions: No external dependencies. formatSessionFacts must handle empty input gracefully. Line truncation must preserve the [task:X] suffix — truncate the object part, not the metadata. | Success: formatSessionFacts([]) returns "". formatSessionFacts with 3 facts returns a properly formatted multi-line string. Lines exceeding 120 chars are truncated. Barrel export compiles and all symbols are accessible via import from src/core/session/index.ts. | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 6. Integrate fact tracker into DispatchRuntimeManager
  - File: src/tools/workflow/dispatch-runtime.ts (modify existing)
  - Add ISessionFactStore, IFactExtractor, IFactRetriever as constructor dependencies
  - Hook extractFromImplementer/extractFromReviewer into ingestOutput() after schema validation
  - Hook retrieve() + formatSessionFacts() into compilePrompt() before building dynamic tail
  - Extend buildDispatchDynamicTail() with optional sessionContext parameter
  - Purpose: Wire the fact tracker into the existing dispatch pipeline
  - _Leverage: src/core/session/index.ts (tasks 1-5), src/tools/workflow/dispatch-runtime.ts (existing)_
  - _Requirements: 1.1, 1.2, 2.1, 3.1, 4.1, 4.2, 4.3_
  - _Prompt: Implement the task for spec session-fact-tracker, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in system integration and dependency injection | Task: Modify DispatchRuntimeManager in src/tools/workflow/dispatch-runtime.ts to integrate the session fact tracker. Changes: (1) Add three new constructor parameters: factStore (ISessionFactStore), factExtractor (IFactExtractor), factRetriever (IFactRetriever). Import types from src/core/session/index.ts. (2) In ingestOutput(), after the implementer schema validation succeeds and result is typed as ImplementerResult, add: const extracted = this.factExtractor.extractFromImplementer(result, args.taskId); this.factStore.add(extracted); — NO try/catch, the extractor guarantees it never throws. Same pattern for reviewer path with extractFromReviewer. (3) In compilePrompt(), after building deltaPacket and resolving taskPrompt but before calling promptCompiler.compile(), add: const facts = this.factRetriever.retrieve({ taskDescription: taskPrompt, taskId: args.taskId, maxFacts: 10, maxTokens: 500 }); const sessionContext = formatSessionFacts(facts); — NO try/catch, the retriever guarantees it never throws (returns [] on error). (4) Extend buildDispatchDynamicTail input type with optional sessionContext?: string. If provided and non-empty, insert it after the guide instruction line and before 'Task prompt:'. (5) Pass sessionContext to buildDispatchDynamicTail call. (6) Update the module-level singleton: const factStore = new InMemorySessionFactStore(); const dispatchRuntimeManager = new DispatchRuntimeManager(new HeuristicComplexityClassifier(), RoutingTable.fromEnvOrDefault(), factStore, new RuleBasedFactExtractor(), new KeywordFactRetriever(factStore)). | Restrictions: Do NOT wrap fact tracker calls in try/catch — each implementation guarantees it never throws (No Defensive Garbage principle). The caller trusts the contract. Do not modify any existing method signatures except buildDispatchDynamicTail (add optional param) and constructor (add 3 params). Keep existing tests passing. | Success: ingestOutput correctly extracts and stores facts after each dispatch. compilePrompt includes [Session Context] in dynamic tail when relevant facts exist. [Session Context] is omitted when no facts are relevant. No try/catch wrappers around fact tracker calls in dispatch-runtime. Existing dispatch-runtime tests still pass. | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 7. Integration tests for multi-task session fact flow
  - File: src/core/session/integration.test.ts
  - Test the full pipeline: ingestOutput for task 1 → facts stored → compilePrompt for task 2 includes task 1 facts
  - Test temporal invalidation across tasks. Test compaction. Test empty session start.
  - Purpose: Verify end-to-end fact flow across simulated multi-task sessions
  - _Leverage: src/core/session/index.ts (tasks 1-5), src/tools/workflow/dispatch-runtime.ts (task 6), src/tools/workflow/dispatch-contract-schemas.ts_
  - _Requirements: All_
  - _Prompt: Implement the task for spec session-fact-tracker, first call get-implementer-guide to load implementation rules then implement the task: Role: QA Engineer specializing in integration testing and multi-step workflows | Task: Create integration tests in src/core/session/integration.test.ts that verify the full session fact tracking pipeline. Tests: (1) "first task in session produces no session context" — create fresh store, extractor, retriever. Call compilePrompt equivalent (retrieve + format) with empty store. Verify result is empty string. (2) "facts from task 1 appear in task 2 prompt" — create ImplementerResult for task 1 with files_modified and summary. Extract facts, add to store. Retrieve for task 2 description that mentions same files. Verify facts are returned and formatted. (3) "reviewer conventions persist across tasks" — extract reviewer result with required_fixes for task 2. Retrieve for task 4. Verify convention facts appear. (4) "temporal invalidation excludes old facts" — add fact for file X modified by task 1. Add fact for file X modified by task 3 (should invalidate task 1's fact). Retrieve for task 4. Verify only task 3's fact appears. (5) "self-exclusion works" — add facts from task 5. Retrieve for task 5. Verify no facts returned. (6) "compaction preserves recent facts" — add 600 facts spanning tasks 1-20. Compact to 500. Verify most recent task facts are preserved. (7) "token budget truncation" — add 50 facts. Retrieve with maxTokens=100. Verify returned facts fit within budget. | Restrictions: Use the concrete implementations (InMemorySessionFactStore, RuleBasedFactExtractor, KeywordFactRetriever). No mocks — these are integration tests. Create realistic ImplementerResult/ReviewerResult objects matching the schema. | Success: All 7 integration tests pass. Tests verify the cross-task fact flow that is the core value proposition of this feature. | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._
