# Tasks: Task-Complexity Classifier for CLI Agent Routing

- [x] 1. Create routing types and ITaskComplexityClassifier interface
  - File: src/core/routing/types.ts
  - Define `ComplexityLevel`, `TaskClassificationInput`, `ClassificationResult`, `ClassificationFeature`, `ITaskComplexityClassifier` interface, `RoutingTableConfig`, `RoutingTableEntry`
  - Pure type definitions — no implementation logic
  - Purpose: Establish type contracts for the entire routing subsystem
  - _Leverage: src/core/llm/types.ts (for pattern reference), src/config/discipline.ts (CanonicalProvider, DispatchRole)_
  - _Requirements: 1, 5_
  - _Prompt: Implement the task for spec task-complexity-classifier, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in type systems and interfaces | Task: Create the routing type definitions and ITaskComplexityClassifier strategy interface in src/core/routing/types.ts. Define ComplexityLevel as 'simple' | 'moderate' | 'complex'. Define TaskClassificationInput with fields: taskDescription (string), fileCount (optional number), estimatedScope (optional 'single-file' | 'multi-file' | 'cross-module'), taskId (optional string), specName (optional string), hints (optional Record<string, string>). Define ClassificationResult with level (ComplexityLevel), confidence (number 0-1), features (ClassificationFeature[]), classifierId (string). Define ClassificationFeature with name (string), value (string | number | boolean), weight (number). Define ITaskComplexityClassifier interface with a single classify(input: TaskClassificationInput): ClassificationResult method. Define RoutingTableConfig mapping each ComplexityLevel to a CanonicalProvider. Import CanonicalProvider and DispatchRole from src/config/discipline.ts. | Restrictions: Pure type file only — no implementation logic, no I/O, no classes. Follow existing type patterns from src/core/llm/types.ts. Do not add defensive garbage or fallback types. | _Leverage: src/core/llm/types.ts, src/config/discipline.ts | _Requirements: Requirement 1 (classification interface), Requirement 5 (strategy pattern) | Success: All types compile without errors, ITaskComplexityClassifier is a clean strategy interface, types are exported and importable from other modules | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 2. Implement HeuristicComplexityClassifier
  - File: src/core/routing/heuristic-classifier.ts
  - Test: src/core/routing/heuristic-classifier.test.ts
  - Implement rule-based classifier using keyword/pattern matching and weighted scoring
  - Feature extractors: keyword match, file count hint, scope hint, description length, action verb
  - Default bias toward 'complex' when ambiguous
  - Purpose: Initial classifier strategy — pure function, no I/O, no LLM calls
  - _Leverage: src/core/routing/types.ts (ITaskComplexityClassifier interface)_
  - _Requirements: 1_
  - _Prompt: Implement the task for spec task-complexity-classifier, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in text analysis and classification | Task: Implement HeuristicComplexityClassifier in src/core/routing/heuristic-classifier.ts implementing ITaskComplexityClassifier from types.ts. The classifier uses weighted feature extraction: (1) keyword_match — scan taskDescription for simple signals ("test stub", "rename", "doc update", "fix typo", "move file", "update import") weighted toward simple, and complex signals ("refactor", "architect", "redesign", "new interface", "cross-module", "implement", "integrate") weighted toward complex; (2) file_count — fileCount of 1 scores simple, 3+ scores complex; (3) scope_hint — estimatedScope 'single-file' scores simple, 'cross-module' scores complex; (4) description_length — <100 chars scores simple, >500 chars scores complex; (5) action_verb — extract first verb from description, map to simple/complex buckets. Each feature produces a weight from -1.0 (simple) to 1.0 (complex). Sum weights and map to ComplexityLevel via thresholds: sum < -0.3 = simple, sum > 0.5 = complex, else moderate. Default bias: when no features match, return complex with confidence 0. classifierId is 'heuristic-v1'. Write TDD tests first in src/core/routing/heuristic-classifier.test.ts covering: "Add test stub for UserService" → simple, "Fix typo in README.md" → simple, "Rename variable from foo to bar" → simple, "Implement OAuth2 flow with PKCE" → complex, "Refactor auth module to use strategy pattern" → complex, "Add error handling to API endpoints" → moderate, empty string → complex (safe default), very long description with complex keywords → complex. | Restrictions: Pure function — no I/O, no async, no LLM calls. No defensive garbage — let bad inputs surface. Do not add logging. | _Leverage: src/core/routing/types.ts | _Requirements: Requirement 1 (classification) | Success: All test cases pass, classifier returns deterministic results for same input, confidence reflects feature coverage, classifierId is 'heuristic-v1' | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 3. Implement RoutingTable
  - File: src/core/routing/routing-table.ts
  - Test: src/core/routing/routing-table.test.ts
  - Map ComplexityLevel to CanonicalProvider per DispatchRole
  - Static factory fromEnvOrDefault() reads SPEC_CONTEXT_ROUTE_SIMPLE, SPEC_CONTEXT_ROUTE_MODERATE, SPEC_CONTEXT_ROUTE_COMPLEX
  - Validates all referenced providers exist in PROVIDER_CATALOG
  - Fails loud on invalid provider at startup
  - Falls back to next tier up when selected provider unavailable for role
  - Purpose: Configurable routing resolution
  - _Leverage: src/config/discipline.ts (PROVIDER_CATALOG, CanonicalProvider, DispatchRole, resolveAgentCli), src/core/routing/types.ts_
  - _Requirements: 2, 3_
  - _Prompt: Implement the task for spec task-complexity-classifier, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in configuration and routing logic | Task: Implement RoutingTable class in src/core/routing/routing-table.ts. Constructor takes RoutingTableConfig (from types.ts). Method resolve(level: ComplexityLevel, role: DispatchRole) returns { provider: CanonicalProvider, cli: string } by looking up the config for the level and calling resolveAgentCli(provider, role) from discipline.ts. Static factory fromEnvOrDefault() reads env vars SPEC_CONTEXT_ROUTE_SIMPLE, SPEC_CONTEXT_ROUTE_MODERATE, SPEC_CONTEXT_ROUTE_COMPLEX — each must be a key in PROVIDER_CATALOG or the factory throws with a clear message naming the bad value. Default mapping: simple → 'codex', moderate → 'claude', complex → 'claude'. Write TDD tests in src/core/routing/routing-table.test.ts covering: default config resolves correctly for each level + both roles, env var overrides work, invalid provider name throws at construction, resolve returns correct CLI string from resolveAgentCli. | Restrictions: No defensive fallbacks for impossible states. Fail loud on bad config. Do not catch errors from resolveAgentCli. | _Leverage: src/config/discipline.ts, src/core/routing/types.ts | _Requirements: Requirement 2 (routing by complexity), Requirement 3 (routing table configuration) | Success: Default mapping works (simple→codex, moderate→claude, complex→claude), env overrides work, invalid provider throws, resolve returns correct CLI commands | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 4. Create barrel export for routing module
  - File: src/core/routing/index.ts
  - Re-export all public types and implementations from the routing module
  - Purpose: Clean import path for consumers
  - _Leverage: src/core/llm/index.ts (barrel export pattern reference)_
  - _Requirements: 5_
  - _Prompt: Implement the task for spec task-complexity-classifier, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer | Task: Create barrel export file src/core/routing/index.ts that re-exports all public types from types.ts (ComplexityLevel, TaskClassificationInput, ClassificationResult, ClassificationFeature, ITaskComplexityClassifier, RoutingTableConfig), HeuristicComplexityClassifier from heuristic-classifier.ts, and RoutingTable from routing-table.ts. Follow the same barrel export pattern as src/core/llm/index.ts. | Restrictions: Only re-exports — no logic, no side effects. | _Leverage: src/core/llm/index.ts | _Requirements: Requirement 5 (clean module boundary) | Success: All public types and classes importable from 'src/core/routing/index.js', no circular dependencies | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 5. Integrate classifier into DispatchRuntimeManager.initRun
  - File: src/tools/workflow/dispatch-runtime.ts (modify)
  - Test: src/tools/workflow/dispatch-runtime.test.ts (modify or create)
  - Inject ITaskComplexityClassifier and RoutingTable into DispatchRuntimeManager constructor
  - In initRun: extract task description from tasks.md _Prompt field, call classifier.classify(), call routingTable.resolve(), store results as snapshot facts (classification_level, selected_provider, classification_features)
  - Return selected provider in initRun response payload
  - Purpose: Wire classification into the dispatch lifecycle
  - _Leverage: src/tools/workflow/dispatch-runtime.ts (DispatchRuntimeManager, initRun, StateSnapshotFact), src/core/routing/index.ts, src/tools/workflow/dispatch-ledger.ts (resolveTasksFilePath)_
  - _Requirements: 1, 2, 4_
  - _Prompt: Implement the task for spec task-complexity-classifier, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in system integration | Task: Modify DispatchRuntimeManager in src/tools/workflow/dispatch-runtime.ts to integrate the task-complexity classifier. Changes: (1) Add constructor parameters for ITaskComplexityClassifier and RoutingTable, imported from src/core/routing/index.ts. (2) In initRun, after extracting progress/task ledgers, read the task's _Prompt field from tasks.md to get the task description. Use the resolveTasksFilePath helper to find tasks.md, read it, and parse the _Prompt for the given taskId. (3) Call this.classifier.classify({ taskDescription, taskId, specName }) to get ClassificationResult. (4) Call this.routingTable.resolve(result.level, 'implementer') to get the selected provider. (5) Store classification results as snapshot facts: { k: 'classification_level', v: result.level, confidence: result.confidence }, { k: 'selected_provider', v: provider.provider, confidence: 1 }, { k: 'classification_features', v: JSON.stringify(result.features), confidence: 1 }. (6) Include selected_provider and classification_level in the initRun STATE_DELTA event payload. (7) If classifier throws, catch and default to { level: 'complex', confidence: 0, features: [], classifierId: 'fallback' } — this is the ONE allowed defensive catch since classification failure must not block dispatch. Write tests verifying: classifier result stored in snapshot facts, selected provider returned, classifier failure defaults to complex. | Restrictions: Do not change the existing initRun signature — add classification as internal behavior. Do not modify ingestOutput or compilePrompt. Keep the classifier catch block minimal — log and default to complex, nothing more. | _Leverage: src/tools/workflow/dispatch-runtime.ts, src/core/routing/index.ts, src/tools/workflow/dispatch-ledger.ts | _Requirements: Requirement 1 (classification at initRun), Requirement 2 (routing), Requirement 4 (BudgetGuard composition) | Success: initRun returns selected_provider in response, snapshot contains classification facts, classifier failure does not break dispatch, existing tests still pass | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._

- [x] 6. Wire default classifier and routing table at server startup
  - File: src/tools/workflow/dispatch-runtime.ts (modify instantiation) or src/tools/index.ts (modify)
  - Instantiate HeuristicComplexityClassifier and RoutingTable.fromEnvOrDefault() and pass to DispatchRuntimeManager
  - Purpose: Connect the default implementations at the composition root
  - _Leverage: src/tools/workflow/dispatch-runtime.ts, src/core/routing/index.ts, src/tools/index.ts_
  - _Requirements: 3, 5_
  - _Prompt: Implement the task for spec task-complexity-classifier, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in dependency injection | Task: Wire the default classifier and routing table at the server's composition root. Find where DispatchRuntimeManager is instantiated (likely in dispatch-runtime.ts module scope or src/tools/index.ts). Create a HeuristicComplexityClassifier instance and a RoutingTable via RoutingTable.fromEnvOrDefault(), then pass both to the DispatchRuntimeManager constructor. Import from src/core/routing/index.ts. If RoutingTable.fromEnvOrDefault() throws due to invalid env config, let it propagate — server should fail to start with a clear error. | Restrictions: Do not add a DI container — simple constructor injection is sufficient. Do not add lazy initialization. | _Leverage: src/tools/workflow/dispatch-runtime.ts, src/core/routing/index.ts, src/tools/index.ts | _Requirements: Requirement 3 (configuration), Requirement 5 (strategy pattern wiring) | Success: Server starts with default classifier and routing table, env var overrides are respected, invalid config prevents startup with clear error | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide._
