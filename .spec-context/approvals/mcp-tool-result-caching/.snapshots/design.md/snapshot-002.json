{
  "id": "snapshot_1770477641910_3wwoji8nu",
  "approvalId": "approval_1770477638991_sqrsmjqg1",
  "approvalTitle": "Design: MCP Tool-Result Caching (Dimension 5 P1)",
  "version": 2,
  "timestamp": "2026-02-07T15:20:41.910Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: MCP Tool-Result Caching (Dimension 5 P1)\n\n## Overview\n\nAdd a shared file-content cache that eliminates redundant disk reads across MCP tool handlers. The cache validates entries via mtime (fast) and content hash (authoritative), reusing the `SourceFingerprint` pattern from `dispatch-ledger.ts`. Three consumers integrate: steering-loader, spec-status, and guide tools.\n\n## Current State\n\n### Already Implemented\n- `dispatch-ledger.ts`: `SourceFingerprint` (mtime + sha256 hash) with `isProgressLedgerStale()` — validates but does not cache\n- `get-implementer-guide.ts`: per-run `Map<string, ImplementerGuideCacheEntry>` keyed on `runId` — no file-change invalidation\n- `get-reviewer-guide.ts`: same pattern as implementer guide\n- `steering-loader.ts`: `readFileSync` on every call, no caching\n\n### Missing\n- Shared file-content cache with mtime+hash invalidation\n- Steering docs served from cache\n- Spec-status parsed results served from cache\n- Guide cache invalidation when steering docs change\n- Cache hit/miss telemetry\n\n## Design Goals\n\n1. Single cache module reused by all consumers (DRY).\n2. Consumers depend on interface, not concrete class (DIP).\n3. Cache concerns separated from tool handler logic (SRP).\n4. Mtime+hash double-check ensures no stale reads (correctness over speed).\n5. Fallthrough to uncached read on any cache error (reliability).\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`dispatch-ledger.ts` `SourceFingerprint`**: Reuse the mtime+hash validation pattern. Extract the shared concept into the cache module.\n- **`steering-loader.ts` `getSteeringDocs`**: Modify to read through cache instead of `readFileSync`.\n- **`SpecParser`**: Used by `spec-status.ts`. Cache wraps the parsed result, keyed on tasks.md fingerprint.\n\n### Integration Points\n- **`get-implementer-guide.ts`**: Existing `implementerGuideCache` gains steering-change invalidation by checking cache fingerprints.\n- **`get-reviewer-guide.ts`**: Same as implementer.\n- **`dispatch-ledger.ts`**: Can optionally consume the shared cache for `extractProgressLedger`, but this is a stretch goal — ledger already has its own staleness check.\n\n## Architecture\n\n```mermaid\ngraph TD\n    FC[FileContentCache] --> |stat + readFile| FS[Filesystem]\n\n    SL[steering-loader] --> FC\n    SS[spec-status] --> FC\n    IG[get-implementer-guide] --> SL\n    RG[get-reviewer-guide] --> SL\n    IG --> |invalidate on steering change| FC\n    RG --> |invalidate on steering change| FC\n```\n\n## Components and Interfaces\n\n### Component 1: FileContentCache\n\n**New file:** `src/core/cache/file-content-cache.ts`\n\n**Purpose:** In-memory cache for file contents, validated via mtime and content hash.\n\n**Interface:**\n```typescript\ninterface FileContentCacheEntry {\n  content: string;\n  mtimeMs: number;\n  hash: string;\n  cachedAt: number;\n}\n\ninterface FileContentCacheTelemetry {\n  hits: number;\n  misses: number;\n  errors: number;\n}\n\ninterface IFileContentCache {\n  get(filePath: string): Promise<string | null>;\n  getFingerprint(filePath: string): { mtimeMs: number; hash: string } | null;\n  getTelemetry(): FileContentCacheTelemetry;\n  invalidate(filePath: string): void;\n  clear(): void;\n}\n```\n\n**Behavior:**\n1. `get(filePath)`:\n   - If no entry exists → `stat` + `readFile` + compute hash → store entry → return content (miss).\n   - If entry exists → `stat` only → compare mtime.\n     - Mtime matches → return cached content (hit).\n     - Mtime differs → `readFile` + compute hash → update entry → return content (miss).\n   - If file does not exist or stat fails → return `null` (miss, no error thrown).\n2. `getFingerprint(filePath)`: Return cached mtime+hash without I/O (for invalidation checks by guide caches).\n3. `invalidate(filePath)`: Remove single entry.\n4. `clear()`: Remove all entries.\n\n**Dependencies:** `fs.promises` (stat, readFile), `crypto` (createHash).\n**No external dependencies.**\n\n### Component 2: Steering Loader Cache Integration\n\n**Modify:** `src/tools/workflow/steering-loader.ts`\n\n**Changes:**\n- Accept `IFileContentCache` parameter (dependency injection).\n- Replace `readFileSync` calls with `cache.get()` (async).\n- `getSteeringDocs` becomes async: `async getSteeringDocs(projectPath, docs, cache?)`.\n- If no cache provided, fall through to direct `readFile` (backward compatible).\n- `getMissingSteeringDocs` remains synchronous (only checks `existsSync`, no content needed).\n\n### Component 3: Spec-Status Cache Integration\n\n**Modify:** `src/tools/workflow/spec-status.ts`\n\n**Changes:**\n- Cache the `SpecParser.getSpec()` result keyed on `{projectPath}:{specName}`.\n- Before parsing, check if tasks.md fingerprint (via `cache.getFingerprint`) matches cached entry.\n- If match → return cached parsed result.\n- If mismatch or no cache → parse fresh, store result with fingerprint.\n\n**Cache entry shape:**\n```typescript\ninterface SpecStatusCacheEntry {\n  result: SpecData;\n  tasksFingerprint: { mtimeMs: number; hash: string } | null;\n}\n```\n\nThis is a separate `Map` inside the spec-status module (not the `FileContentCache` itself, since the cached value is a parsed object, not raw file content). But it uses `FileContentCache.getFingerprint()` to check staleness.\n\n### Component 4: Guide Cache Invalidation\n\n**Modify:** `src/tools/workflow/get-implementer-guide.ts`, `src/tools/workflow/get-reviewer-guide.ts`\n\n**Changes:**\n- On compact mode cache hit, check if steering doc fingerprints have changed since guide was cached.\n- Store steering fingerprints alongside guide cache entry:\n  ```typescript\n  interface ImplementerGuideCacheEntry {\n    guide: string;\n    disciplineMode: 'full' | 'standard' | 'minimal';\n    steering: Record<string, string>;\n    steeringFingerprints: Record<string, { mtimeMs: number; hash: string }>;\n    cachedAt: string;\n  }\n  ```\n- On compact lookup: compare stored fingerprints against `cache.getFingerprint()` for each steering doc.\n- If any fingerprint differs → invalidate guide entry, force full reload.\n\n## Data Flow\n\n### Cache Hit Path (steering doc)\n```\nguide handler → steering-loader.getSteeringDocs()\n  → cache.get(\"/.../steering/tech.md\")\n    → stat() → mtime matches → return cached content\n  ← content (no readFile)\n```\n\n### Cache Miss Path (steering doc changed)\n```\nguide handler → steering-loader.getSteeringDocs()\n  → cache.get(\"/.../steering/tech.md\")\n    → stat() → mtime differs → readFile() → hash → update entry\n  ← fresh content\n```\n\n### Guide Invalidation Path\n```\nguide handler (compact mode) → check guide cache\n  → guide entry exists → check steering fingerprints\n    → cache.getFingerprint(\"tech.md\") → mtime changed\n  → invalidate guide entry → fall through to full mode\n```\n\n## Error Handling\n\n- `stat` fails (ENOENT, EACCES) → return `null` from `cache.get()`, increment error counter. No throw.\n- `readFile` fails → return `null`, increment error counter. No throw.\n- Hash computation fails → treat as miss, return uncached content if available.\n- Guide fingerprint check fails → treat as miss, recompile guide (safe default).\n\nPer \"No Defensive Garbage\" principle: these are genuine I/O boundary errors, not impossible-case fallbacks. The cache is an optimization layer — degrading to uncached reads on I/O errors is the correct behavior, not a defensive hack.\n\n## Testing Strategy\n\n### Unit Tests\n\n**New file:** `src/core/cache/file-content-cache.test.ts`\n- Cache miss on first read → returns content, telemetry shows miss.\n- Cache hit on second read (mtime unchanged) → returns same content, telemetry shows hit, no `readFile` call.\n- Cache invalidation on mtime change → re-reads file, returns fresh content.\n- File not found → returns `null`, no throw.\n- `getFingerprint()` returns stored mtime+hash.\n- `invalidate()` removes entry.\n- `clear()` removes all entries.\n\n**Modify:** `src/tools/workflow/steering-loader.test.ts` (if exists, else new)\n- Steering docs served from cache on repeated calls.\n- Cache invalidated when steering file mtime changes.\n\n**Modify:** `src/tools/workflow/spec-status.test.ts` (if exists)\n- Spec-status returns cached result when tasks.md unchanged.\n- Spec-status re-parses when tasks.md mtime changes.\n\n**Modify:** `src/tools/workflow/get-implementer-guide.test.ts`\n- Compact mode invalidates when steering doc fingerprint changes.\n\n**Modify:** `src/tools/workflow/get-reviewer-guide.test.ts`\n- Same as implementer guide.\n\n### Integration Tests\n- End-to-end: guide tool call → steering loaded from cache → second call hits cache → modify steering file → third call re-reads.\n\n## File Changes\n\n### New\n- `src/core/cache/file-content-cache.ts`\n- `src/core/cache/file-content-cache.test.ts`\n\n### Modified\n- `src/tools/workflow/steering-loader.ts` (async, cache integration)\n- `src/tools/workflow/spec-status.ts` (cache integration)\n- `src/tools/workflow/get-implementer-guide.ts` (steering fingerprint invalidation)\n- `src/tools/workflow/get-reviewer-guide.ts` (steering fingerprint invalidation)\n- Existing test files for above modules\n\n## Risks and Mitigations\n\n- **Risk:** `steering-loader.ts` going async breaks callers.\n  - **Mitigation:** Audit all callers. `getSteeringDocs` is only called from async tool handlers (`getImplementerGuideHandler`, `getReviewerGuideHandler`, `specWorkflowGuideHandler`). The change is safe.\n- **Risk:** Cache grows unbounded.\n  - **Mitigation:** Steering docs are 4 files max. Spec-status cache is keyed per specName. Guide caches are keyed per runId (bounded by session lifetime). Total memory is negligible.\n- **Risk:** Mtime resolution insufficient on some filesystems.\n  - **Mitigation:** Mtime is fast-path only. Content hash is authoritative fallback on mtime match with content change (already the `dispatch-ledger.ts` pattern).\n",
  "fileStats": {
    "size": 9801,
    "lines": 238,
    "lastModified": "2026-02-07T15:20:34.788Z"
  },
  "comments": []
}