{
  "id": "snapshot_1770486927574_v4os3a394",
  "approvalId": "approval_1770486927573_swy1pz3jz",
  "approvalTitle": "Session Fact Tracker — Design",
  "version": 1,
  "timestamp": "2026-02-07T17:55:27.574Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: Session Fact Tracker\n\n## Overview\n\nA lightweight in-memory fact tracking system that sits between `ingest_output` (where dispatch results arrive) and `compile_prompt` (where dispatch prompts are assembled). It extracts structured facts from each dispatch result using rule-based parsing, stores them for the session lifetime, and injects only relevant facts into subsequent dispatch prompts. Zero LLM cost, zero external dependencies, single-session scope.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- TypeScript, async/await for any future I/O extension points\n- In-memory storage, no database dependencies\n- Interfaces for all public contracts (DIP)\n\n### Project Structure (structure.md)\n- New modules under `src/core/session/` for domain logic (fact store, extractor, retriever)\n- Integration hooks in existing `src/tools/workflow/dispatch-runtime.ts`\n- Tests alongside source in `src/core/session/*.test.ts`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`StateSnapshotFact`** (`src/core/llm/types.ts`): Existing fact type `{ k, v, confidence }`. The session fact tracker uses a richer `SessionFact` type but converts to/from `StateSnapshotFact` at the integration boundary.\n- **`DispatchRuntimeManager.mergeFacts()`** (`src/tools/workflow/dispatch-runtime.ts:1317`): Existing key-based merge. Session facts use a different identity model (subject+relation+object triple vs single key) so they get their own store, but the merge pattern is reused conceptually.\n- **`ImplementerResult` / `ReviewerResult`** (`src/tools/workflow/dispatch-contract-schemas.ts`): The structured JSON schemas that fact extraction parses. Already validated by `SchemaRegistry` before reaching the extractor.\n- **`buildDispatchDynamicTail()`** (`src/tools/workflow/dispatch-runtime.ts:476`): The function where `[Session Context]` injection happens. Extended to accept an optional facts string.\n\n### Integration Points\n- **`DispatchRuntimeManager.ingestOutput()`**: After schema validation succeeds, call `IFactExtractor.extract()` on the validated result and store in `ISessionFactStore`.\n- **`DispatchRuntimeManager.compilePrompt()`**: Before building the dynamic tail, call `IFactRetriever.retrieve()` to get relevant facts, format them, and include in the tail.\n\n## Architecture\n\n```\n                    DispatchRuntimeManager\n                    /         |          \\\n            initRun()    ingestOutput()   compilePrompt()\n                              |                |\n                    ┌─────────┴──────┐    ┌────┴─────────┐\n                    │ IFactExtractor │    │IFactRetriever│\n                    └────────┬───────┘    └────┬─────────┘\n                             │                 │\n                      ┌──────┴─────────────────┴──────┐\n                      │      ISessionFactStore        │\n                      │  Map<string, SessionFact>     │\n                      │  (in-memory, session-scoped)  │\n                      └───────────────────────────────┘\n```\n\n## Components and Interfaces\n\n### Component 1: SessionFact (Value Object)\n\n```typescript\ninterface SessionFact {\n  readonly id: string;           // deterministic: hash(subject + relation + object)\n  readonly subject: string;      // e.g., \"src/services/FooService.ts\"\n  readonly relation: string;     // e.g., \"created_by\", \"flagged_in\", \"convention\"\n  readonly object: string;       // e.g., \"task-3\", \"naming: use camelCase\"\n  readonly tags: ReadonlyArray<SessionFactTag>;\n  readonly validFrom: Date;\n  readonly validTo?: Date;       // set when temporally invalidated\n  readonly sourceTaskId: string;\n  readonly sourceRole: 'implementer' | 'reviewer';\n  readonly confidence: number;   // 0-1\n}\n\ntype SessionFactTag = 'file_change' | 'convention' | 'decision' | 'error' | 'dependency' | 'test';\n```\n\n**Purpose:** Immutable value object representing a single cross-task fact. Identity is the (subject, relation, object) triple. Temporal validity via `validFrom`/`validTo`.\n\n### Component 2: ISessionFactStore\n\n```typescript\ninterface ISessionFactStore {\n  add(facts: SessionFact[]): void;\n  invalidate(subject: string, relation: string): void;\n  getValid(): SessionFact[];\n  getValidByTags(tags: SessionFactTag[]): SessionFact[];\n  count(): number;\n  compact(maxFacts: number): void;\n}\n```\n\n**Purpose:** In-memory store for session facts. Keyed by fact ID. `invalidate()` sets `validTo` on matching facts. `compact()` deduplicates and trims when count exceeds threshold.\n**Dependencies:** None (pure in-memory).\n**Reuses:** Merge pattern from `DispatchRuntimeManager.mergeFacts()`.\n\n**Implementation:** `InMemorySessionFactStore` backed by `Map<string, SessionFact>`. On `add()`, if a fact with the same `subject+relation` already exists and is valid, auto-invalidate the old one. `compact()` keeps most recent N facts by `validFrom`, discards oldest invalidated facts first.\n\n### Component 3: IFactExtractor\n\n```typescript\ninterface IFactExtractor {\n  extractFromImplementer(result: ImplementerResult, taskId: string): SessionFact[];\n  extractFromReviewer(result: ReviewerResult, taskId: string): SessionFact[];\n}\n```\n\n**Purpose:** Rule-based extraction of `SessionFact` instances from validated dispatch results. No LLM calls.\n**Dependencies:** `ImplementerResult`, `ReviewerResult` types from `dispatch-contract-schemas.ts`.\n\n**Extraction Rules:**\n\n| Source Field | Fact Subject | Relation | Object | Tag |\n|-------------|-------------|----------|--------|-----|\n| `implementer.status` | `task:{taskId}` | `completed_with` | status value | `decision` |\n| `implementer.summary` | `task:{taskId}` | `summary` | summary text (clipped 120 chars) | `decision` |\n| `implementer.files_modified[]` | file path | `modified_by` | `task:{taskId}` | `file_change` |\n| `implementer.follow_up_actions[]` | `task:{taskId}` | `requires` | action text | `dependency` |\n| `reviewer.assessment` | `task:{taskId}` | `reviewed_as` | assessment value | `decision` |\n| `reviewer.issues[].message` | issue file or `task:{taskId}` | `issue` | message (clipped 120 chars) | `error` |\n| `reviewer.required_fixes[]` | `task:{taskId}` | `must_fix` | fix text (clipped 120 chars) | `convention` |\n\n**Implementation:** `RuleBasedFactExtractor`. Each rule is a pure function `(result, taskId) => SessionFact[]`. Rules are registered in an array, iterated sequentially. New rules added by appending to the array (OCP).\n\n### Component 4: IFactRetriever\n\n```typescript\ninterface IFactRetriever {\n  retrieve(query: FactQuery): SessionFact[];\n}\n\ninterface FactQuery {\n  taskDescription: string;\n  taskId: string;\n  tags?: SessionFactTag[];\n  maxFacts: number;\n  maxTokens: number;\n}\n```\n\n**Purpose:** Given a task context, retrieve the most relevant valid facts from the store.\n**Dependencies:** `ISessionFactStore`.\n\n**Retrieval Strategy (sequential filtering):**\n\n1. **Get valid facts** — exclude `validTo !== undefined`\n2. **Tag filter** — if `query.tags` provided, keep only facts with matching tags; otherwise keep all\n3. **Exclude self** — exclude facts where `sourceTaskId === query.taskId` (task already knows its own context)\n4. **Score by keyword overlap** — tokenize `query.taskDescription` into words, score each fact by overlap with `subject + relation + object`\n5. **Sort** — by score descending, then by `validFrom` descending (most recent wins ties)\n6. **Truncate** — take top `maxFacts`, then truncate to `maxTokens` budget (estimate 4 chars/token)\n\n**Implementation:** `KeywordFactRetriever`. Keyword tokenization: split on whitespace and common delimiters, lowercase, remove stopwords (a, the, is, etc. — hardcoded set of ~30 words).\n\n### Component 5: Prompt Integration (in DispatchRuntimeManager)\n\nNo new class. Modifications to `buildDispatchDynamicTail()` and `DispatchRuntimeManager.compilePrompt()`:\n\n```typescript\n// In compilePrompt(), after building deltaPacket, before compiling:\nconst relevantFacts = this.factRetriever.retrieve({\n  taskDescription: taskPrompt,\n  taskId: args.taskId,\n  maxFacts: 10,\n  maxTokens: 500,\n});\nconst sessionContext = formatSessionFacts(relevantFacts);\n// sessionContext is \"\" if no facts, otherwise \"[Session Context]\\n- fact1\\n- fact2\\n...\"\n```\n\n```typescript\n// In buildDispatchDynamicTail(), add sessionContext parameter:\nfunction buildDispatchDynamicTail(input: {\n  // ... existing fields ...\n  sessionContext?: string;  // NEW\n}): string {\n  const sections = [\n    `Task ID: ${input.taskId}`,\n    `Max output tokens: ${input.maxOutputTokens}`,\n    `Delta context: ${JSON.stringify(input.deltaPacket)}`,\n    `Guide cache key: ${input.guideCacheKey}`,\n    guideInstruction,\n  ];\n  if (input.sessionContext) {\n    sections.push(input.sessionContext);  // injected between delta and task prompt\n  }\n  sections.push('Task prompt:', input.taskPrompt);\n  return sections.join('\\n');\n}\n```\n\n**Fact formatting:**\n```\n[Session Context]\n- src/services/FooService.ts modified_by task:2 [file_change]\n- task:4 reviewed_as needs_changes [decision]\n- naming: use camelCase for service methods convention task:4 [convention]\n```\n\nEach line max 120 chars. Section omitted entirely if no relevant facts.\n\n## Data Models\n\n### SessionFact\n```\nid: string (SHA-256 hash of subject+relation+object, truncated to 16 chars)\nsubject: string (max 200 chars)\nrelation: string (max 50 chars)\nobject: string (max 200 chars)\ntags: SessionFactTag[] (1-3 tags per fact)\nvalidFrom: Date\nvalidTo: Date | undefined\nsourceTaskId: string\nsourceRole: 'implementer' | 'reviewer'\nconfidence: number (0-1, default 1 for rule-based extraction)\n```\n\n### InMemorySessionFactStore internal state\n```\nfacts: Map<string, SessionFact>  // keyed by fact.id\nindex_by_subject: Map<string, Set<string>>  // subject -> fact IDs (for fast invalidation)\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Fact extraction fails on malformed result field**\n   - **Handling:** Catch, log warning, skip that field. Other fields still extracted. Dispatch continues.\n   - **User Impact:** None. Fact store has fewer facts but dispatch is unaffected.\n\n2. **Fact store exceeds max capacity**\n   - **Handling:** `compact()` called automatically before `add()` when count exceeds threshold. Removes oldest invalidated facts first, then oldest valid facts.\n   - **User Impact:** None. Oldest facts pruned, recent facts preserved.\n\n3. **Fact retrieval returns empty set**\n   - **Handling:** `[Session Context]` section omitted from prompt. No placeholder.\n   - **User Impact:** None. Dispatch works exactly as it does today without the fact tracker.\n\n4. **Token budget exceeded for facts section**\n   - **Handling:** Facts truncated to fit within `maxTokens`. Highest-scored facts kept.\n   - **User Impact:** None. Most relevant facts still included.\n\n## Testing Strategy\n\n### Unit Testing\n- `InMemorySessionFactStore`: add, invalidate, getValid, compact, count\n- `RuleBasedFactExtractor`: extract from implementer result, extract from reviewer result, handle missing fields, handle empty arrays\n- `KeywordFactRetriever`: scoring, tag filtering, self-exclusion, token budget truncation, empty store\n- `formatSessionFacts`: formatting, line truncation, empty input\n\n### Integration Testing\n- Full flow: ingestOutput → extract facts → compilePrompt → facts appear in dynamic tail\n- Multi-task session: task 1 facts available during task 3 prompt compilation\n- Temporal invalidation: fact from task 2 invalidated by task 4, not included in task 5 prompt\n- Compaction: store with 600 facts compacts to 500 without losing recent facts\n\n### Edge Cases\n- Implementer result with no `files_modified` field → zero `file_change` facts, no error\n- Reviewer result with 0 issues → zero `error` facts, no error\n- Task with no keyword overlap to any stored facts → empty `[Session Context]`, no error\n- First task in session → no facts stored yet → prompt compiled without `[Session Context]`\n",
  "fileStats": {
    "size": 12187,
    "lines": 254,
    "lastModified": "2026-02-07T17:55:23.923Z"
  },
  "comments": []
}