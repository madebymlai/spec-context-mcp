{
  "id": "snapshot_1770348619783_ahfr8v231",
  "approvalId": "approval_1770348619782_554x8tvrm",
  "approvalTitle": "Observation Masking — Design",
  "version": 1,
  "timestamp": "2026-02-06T03:30:19.783Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Observation Masking (Sliding Window)\n\n## Overview\n\nRefactor the `HistoryReducer` to implement a graduated reduction pipeline: **mask old observations first**, then summarize if needed, then fall back to truncation. The key insight from JetBrains Research is that agent actions and reasoning are high-value context (decisions, plans, constraints), while tool-result observations are low-value once consumed (file contents, command output, search results). By selectively masking observations outside the sliding window while preserving all agent turns, context cost drops ~50% with no quality loss.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Extends the existing `HistoryReducer` class in `src/core/llm/history-reducer.ts`\n- Pure TypeScript, no new dependencies\n- Follows existing pattern: stateless functions operating on `ChatMessage[]` arrays\n- Tests colocated as `history-reducer.test.ts` (existing file extended)\n\n### Project Structure (structure.md)\n- All changes within `src/core/llm/` — no new files needed\n- Extends existing `types.ts` interface with optional fields (backward compatible)\n- Existing test file extended with new test cases\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`HistoryReducer`** (`src/core/llm/history-reducer.ts`): Extend with masking stage before summarization\n- **`collectPairGroups()`** / **`includePairMates()`**: Reuse for pair-invariant enforcement post-masking\n- **`hasPairInvariantViolation()`**: Reuse as safety check after masking\n- **`buildSummary()`**: Reuse unchanged for the summarization stage\n- **`truncationFallback()`**: Reuse unchanged as final fallback\n- **`clipText()`**: Reuse for truncating observations to `maxObservationChars`\n\n### Integration Points\n- **`HistoryReducerOptions`** in `types.ts`: Add optional masking configuration fields\n- **`HistoryReductionResult`** in `history-reducer.ts`: Extend with masking telemetry fields\n- **`ChatRuntimeOptions`** in `types.ts`: No change needed (passes through `HistoryReducerOptions`)\n- **Dispatch runtime** (`src/tools/workflow/dispatch-runtime.ts`): Consumer of history reduction — benefits automatically from better reduction\n\n## Architecture\n\n### Graduated Reduction Pipeline\n\nThe reducer applies three stages in order, stopping as soon as context fits within budget:\n\n```mermaid\ngraph TD\n    START[reduce called] --> CHECK_SIZE{context > maxInputChars?}\n    CHECK_SIZE -->|No| RETURN_UNCHANGED[Return unchanged]\n    CHECK_SIZE -->|Yes| STAGE1[Stage 1: Mask old observations]\n\n    STAGE1 --> CHECK1{fits budget?}\n    CHECK1 -->|Yes| RETURN_MASKED[Return with reductionStage: masking]\n    CHECK1 -->|No| STAGE2[Stage 2: Summarize old messages]\n\n    STAGE2 --> CHECK2{fits budget + invariants ok?}\n    CHECK2 -->|Yes| RETURN_SUMMARIZED[Return with reductionStage: summarization]\n    CHECK2 -->|No| STAGE3[Stage 3: Truncation fallback]\n\n    STAGE3 --> RETURN_FALLBACK[Return with reductionStage: fallback]\n\n    style STAGE1 fill:#e1f5e1\n    style STAGE2 fill:#fff4e6\n    style STAGE3 fill:#ffe6e6\n```\n\n### Observation Masking Detail\n\n```mermaid\ngraph LR\n    subgraph \"Sliding Window (recent N turns)\"\n        R_CALL[assistant: call tool X]\n        R_RESULT[tool: full result content]\n        R_REASON[assistant: based on result...]\n    end\n\n    subgraph \"Outside Window (old turns)\"\n        O_CALL[assistant: call tool Y]\n        O_RESULT[\"tool: [observation masked — 4200 chars]\"]\n        O_REASON[assistant: the file shows...]\n    end\n\n    style R_RESULT fill:#e1f5e1\n    style O_RESULT fill:#ffe6e6\n    style O_CALL fill:#e1f5e1\n    style O_REASON fill:#e1f5e1\n    style R_CALL fill:#e1f5e1\n    style R_REASON fill:#e1f5e1\n```\n\n**Key principle**: Agent messages (`role === 'assistant'`) and user messages (`role === 'user'`) are never masked. Only `pairRole === 'result'` messages outside the window get masked.\n\n## Components and Interfaces\n\n### Component 1: Observation Masker (internal function)\n\n- **Purpose:** Mask old tool-result observations while preserving message structure\n- **Interface:**\n  ```typescript\n  function maskObservations(\n      messages: ChatMessage[],\n      keepIndices: Set<number>,\n      options: { maxObservationChars: number }\n  ): { messages: ChatMessage[]; maskedCount: number; maskedChars: number }\n  ```\n- **Dependencies:** None (pure function)\n- **Behavior:**\n  - For each message NOT in `keepIndices`:\n    - If `pairRole === 'result'`: replace content with placeholder, preserving metadata\n    - If dispatch result (contains `BEGIN_DISPATCH_RESULT`): preserve structured JSON block, mask surrounding output\n    - All other messages: leave unchanged (agent actions, user messages preserved)\n  - Returns new array (no mutation)\n\n### Component 2: Dispatch Result Detector (internal function)\n\n- **Purpose:** Identify and extract structured blocks from dispatch results\n- **Interface:**\n  ```typescript\n  function maskDispatchObservation(\n      content: string,\n      maxChars: number\n  ): { masked: string; maskedChars: number }\n  ```\n- **Dependencies:** None (pure function)\n- **Behavior:**\n  - Searches for `BEGIN_DISPATCH_RESULT` / `END_DISPATCH_RESULT` delimiters\n  - If found: keeps the structured block, replaces everything outside with placeholder\n  - If not found: applies standard masking (full replacement)\n\n### Component 3: Extended HistoryReducer.reduce() (modified method)\n\n- **Purpose:** Orchestrate the graduated reduction pipeline\n- **Interface:** Same signature, extended options and result\n  ```typescript\n  reduce(messages: ChatMessage[], options: HistoryReducerOptions): HistoryReductionResult\n  ```\n- **Dependencies:** `maskObservations`, `maskDispatchObservation`, existing `buildSummary`, `truncationFallback`\n- **Behavior:**\n  1. Early return if disabled or within budget (unchanged)\n  2. Compute `keepIndices` from sliding window + system messages\n  3. **Stage 1**: Call `maskObservations()` — if result fits budget, return\n  4. **Stage 2**: Apply existing `buildSummary()` on non-kept, non-system messages from masked result — if fits, return\n  5. **Stage 3**: Call existing `truncationFallback()`\n  6. Pair invariant check after each stage\n\n## Data Models\n\n### Extended HistoryReducerOptions\n```typescript\ninterface HistoryReducerOptions {\n    enabled?: boolean;\n    maxInputChars: number;\n    preserveRecentRawTurns?: number;    // existing, default 4\n    summaryMaxChars?: number;           // existing, default 1400\n    observationMasking?: boolean;       // NEW — default true when enabled\n    maxObservationChars?: number;       // NEW — default 80\n}\n```\n\n### Extended HistoryReductionResult\n```typescript\ninterface HistoryReductionResult {\n    messages: ChatMessage[];\n    reduced: boolean;\n    droppedCount: number;\n    invariantStatus: 'ok' | 'fallback';\n    maskedCount?: number;               // NEW — observations masked\n    maskedChars?: number;               // NEW — total chars removed\n    reductionStage?: 'masking' | 'summarization' | 'fallback';  // NEW\n}\n```\n\n### Masking Placeholder Format\n```\n[observation masked — {originalLength} chars]\n```\nFor dispatch results:\n```\n[dispatch output masked — {maskedLength} chars]\nBEGIN_DISPATCH_RESULT\n{...structured JSON preserved...}\nEND_DISPATCH_RESULT\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Pair invariant violation after masking**\n   - **Handling:** Skip to summarization stage; if still violated, fall to truncation fallback\n   - **User Impact:** None — fallback is invisible, just less efficient\n\n2. **Masking increases size (impossible by design, defensive check)**\n   - **Handling:** Assert maskedChars >= 0; if negative, skip masking stage\n   - **User Impact:** None — proceeds to summarization\n\n3. **No maskable observations (all results within window)**\n   - **Handling:** Masking stage is a no-op (maskedCount=0), proceed to summarization\n   - **User Impact:** None — behaves like current reducer\n\n## Testing Strategy\n\n### Unit Testing\n- **Masking stage isolation**: Verify only `pairRole === 'result'` messages outside window are masked\n- **Agent message preservation**: Verify `role === 'assistant'` messages are never masked regardless of position\n- **Dispatch result preservation**: Verify structured JSON blocks survive masking while surrounding prose is removed\n- **Graduated pipeline**: Verify masking-only when sufficient, summarization when masking insufficient, fallback when both insufficient\n- **Pair invariants**: Verify masked messages retain `pairId`/`pairRole`/`toolCallId` metadata\n- **Telemetry**: Verify `maskedCount`, `maskedChars`, `reductionStage` are populated correctly\n- **Backward compatibility**: Verify `observationMasking: false` produces identical behavior to current reducer\n- **Default behavior**: Verify masking is on by default when `enabled: true`\n\n### Integration Testing\n- **End-to-end pipeline**: Feed realistic conversation with many tool results, verify context reduction ratio\n- **Budget edge cases**: Verify behavior at exact budget boundary (masking just barely sufficient/insufficient)\n\n## File Changes\n\n### Modified Files\n- `src/core/llm/history-reducer.ts` — Add masking stage to `reduce()`, add internal masking functions\n- `src/core/llm/types.ts` — Extend `HistoryReducerOptions` and `HistoryReductionResult` with new optional fields\n- `src/core/llm/history-reducer.test.ts` — Add test cases for masking, dispatch detection, graduated pipeline, telemetry\n\n### No New Files\nAll changes are extensions to existing modules. No new files needed.\n",
  "fileStats": {
    "size": 9538,
    "lines": 222,
    "lastModified": "2026-02-06T03:30:16.261Z"
  },
  "comments": []
}