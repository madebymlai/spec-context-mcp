{
  "id": "snapshot_1770348697400_oeii5m4a4",
  "approvalId": "approval_1770348694455_otox3xi74",
  "approvalTitle": "Observation Masking — Tasks",
  "version": 2,
  "timestamp": "2026-02-06T03:31:37.399Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks Document: Observation Masking (Sliding Window)\n\n- [ ] 1. Extend HistoryReducerOptions and HistoryReductionResult types\n  - File: src/core/llm/types.ts\n  - Add `observationMasking?: boolean` and `maxObservationChars?: number` to `HistoryReducerOptions`\n  - Add `maskedCount?: number`, `maskedChars?: number`, `reductionStage?: 'masking' | 'summarization' | 'fallback'` to `HistoryReductionResult`\n  - Purpose: Establish type contracts for masking feature with backward compatibility\n  - _Leverage: src/core/llm/types.ts, src/core/llm/history-reducer.ts_\n  - _Requirements: 3, 6_\n  - _Prompt: Implement the task for spec observation-masking, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in type systems | Task: Extend HistoryReducerOptions in src/core/llm/types.ts with two optional fields: `observationMasking?: boolean` (default true when enabled) and `maxObservationChars?: number` (default 80). Extend HistoryReductionResult in src/core/llm/history-reducer.ts with three optional fields: `maskedCount?: number`, `maskedChars?: number`, `reductionStage?: 'masking' | 'summarization' | 'fallback'`. All new fields are optional to maintain backward compatibility. | Restrictions: Do NOT modify any existing field types or remove any existing fields. Do NOT change the HistoryReducer class logic yet. Only extend the interfaces. | _Leverage: src/core/llm/types.ts for HistoryReducerOptions, src/core/llm/history-reducer.ts for HistoryReductionResult | _Requirements: Requirement 3 (configurable masking), Requirement 6 (reduction telemetry) | Success: (1) TypeScript compiles with no errors, (2) existing tests pass unchanged, (3) new fields are optional and do not break existing callers, (4) tests verify the new fields exist on the interfaces | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide. Do NOT start the next task until review is approved._\n\n- [ ] 2. Implement maskObservations internal function\n  - File: src/core/llm/history-reducer.ts\n  - Create pure function that replaces content of old `pairRole === 'result'` messages with masking placeholder\n  - Preserve message metadata (pairId, pairRole, role, toolCallId)\n  - Return new array with maskedCount and maskedChars telemetry\n  - Purpose: Core masking logic — selectively truncate observations while preserving agent actions\n  - _Leverage: src/core/llm/history-reducer.ts (clipText, collectPairGroups), src/core/llm/types.ts (ChatMessage)_\n  - _Requirements: 1, 4_\n  - _Prompt: Implement the task for spec observation-masking, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in data transformation | Task: Create a pure internal function `maskObservations` in src/core/llm/history-reducer.ts. Signature: `function maskObservations(messages: ChatMessage[], keepIndices: Set<number>, options: { maxObservationChars: number }): { messages: ChatMessage[]; maskedCount: number; maskedChars: number }`. For each message NOT in keepIndices where `pairRole === 'result'`: replace `content` with `[observation masked — {originalLength} chars]` (up to maxObservationChars). Preserve all metadata fields (pairId, pairRole, role, toolCallId, name, tags). Messages without `pairRole === 'result'` or within keepIndices are copied unchanged. Return a NEW array (no mutation). | Restrictions: Do NOT modify the HistoryReducer.reduce() method yet — that is task 4. Do NOT handle dispatch result detection — that is task 3. Keep function pure and stateless. Place it as a module-level function (not exported, not on the class). | _Leverage: src/core/llm/history-reducer.ts for clipText utility and ChatMessage shape | _Requirements: Requirement 1 (observation-only masking), Requirement 4 (pair invariant preservation) | Success: (1) Only pairRole==='result' messages outside keepIndices get masked, (2) all metadata fields preserved, (3) maskedCount and maskedChars accurate, (4) assistant/user/system messages never masked, (5) messages within keepIndices never masked, (6) no mutation of input array | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide. Do NOT start the next task until review is approved._\n\n- [ ] 3. Implement maskDispatchObservation internal function\n  - File: src/core/llm/history-reducer.ts\n  - Create pure function that detects `BEGIN_DISPATCH_RESULT`/`END_DISPATCH_RESULT` delimiters in tool result content\n  - Preserve the structured JSON block between delimiters, mask everything outside\n  - Fall back to standard masking if delimiters not found\n  - Purpose: Smart masking for dispatch results — keep structured data, drop verbose CLI output\n  - _Leverage: src/core/llm/history-reducer.ts, src/tools/workflow/dispatch-runtime.ts (for delimiter format reference)_\n  - _Requirements: 5_\n  - _Prompt: Implement the task for spec observation-masking, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in text parsing | Task: Create a pure internal function `maskDispatchObservation` in src/core/llm/history-reducer.ts. Signature: `function maskDispatchObservation(content: string, maxChars: number): { masked: string; maskedChars: number }`. Search content for `BEGIN_DISPATCH_RESULT` and `END_DISPATCH_RESULT` delimiters. If found: preserve everything from BEGIN to END (inclusive of delimiter lines), replace all content outside with `[dispatch output masked — {maskedLength} chars]\\n`. If NOT found: return `{ masked: '[observation masked — {content.length} chars]', maskedChars: content.length - placeholder.length }`. maskedChars = original length - masked length. | Restrictions: Do NOT integrate into maskObservations yet — that integration is part of task 4. Keep function pure. Do NOT import from dispatch-runtime.ts — just use string matching for delimiters. | _Leverage: src/tools/workflow/dispatch-runtime.ts for reference on delimiter format (BEGIN_DISPATCH_RESULT / END_DISPATCH_RESULT) | _Requirements: Requirement 5 (dispatch-result observation masking) | Success: (1) Structured JSON block between delimiters preserved exactly, (2) content outside delimiters replaced with placeholder, (3) maskedChars accurately reflects bytes saved, (4) falls back to standard masking when no delimiters found, (5) handles edge cases (delimiters at start/end, no content outside delimiters) | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide. Do NOT start the next task until review is approved._\n\n- [ ] 4. Integrate masking into HistoryReducer.reduce() as graduated pipeline\n  - File: src/core/llm/history-reducer.ts\n  - Refactor reduce() to apply 3-stage pipeline: (1) mask observations, (2) summarize, (3) truncation fallback\n  - Integrate maskObservations with maskDispatchObservation for dispatch-result-aware masking\n  - Wire up new HistoryReducerOptions fields (observationMasking, maxObservationChars)\n  - Populate telemetry fields (maskedCount, maskedChars, reductionStage) in result\n  - Purpose: Wire all pieces together into the graduated reduction pipeline\n  - _Leverage: src/core/llm/history-reducer.ts (all existing functions + new masking functions from tasks 2-3), src/core/llm/types.ts_\n  - _Requirements: 1, 2, 3, 4, 5, 6_\n  - _Prompt: Implement the task for spec observation-masking, first call get-implementer-guide to load implementation rules then implement the task: Role: TypeScript Developer specializing in refactoring and pipeline design | Task: Refactor `HistoryReducer.reduce()` in src/core/llm/history-reducer.ts to implement a 3-stage graduated reduction pipeline. Stage 1 (masking): compute keepIndices from system messages + sliding window, call maskObservations() — for each result message being masked, check if content contains 'BEGIN_DISPATCH_RESULT' and if so use maskDispatchObservation() instead of standard placeholder. If masked result fits budget, return with reductionStage='masking'. Stage 2 (summarization): apply existing buildSummary() on non-kept non-system messages from masked result. If fits budget and no pair violation, return with reductionStage='summarization'. Stage 3: call existing truncationFallback() with reductionStage='fallback'. Read observationMasking option (default true when enabled=true), maxObservationChars (default 80). When observationMasking is false, skip Stage 1 entirely (backward compat). Always populate maskedCount, maskedChars, reductionStage in result. | Restrictions: Do NOT change function signatures of buildSummary, truncationFallback, hasPairInvariantViolation, collectPairGroups, or includePairMates. Do NOT remove existing tests — they must still pass. Pair invariant check must run after each stage. | _Leverage: src/core/llm/history-reducer.ts (maskObservations from task 2, maskDispatchObservation from task 3, buildSummary, truncationFallback, hasPairInvariantViolation, collectPairGroups, includePairMates) | _Requirements: Requirement 1 (observation-only masking), Requirement 2 (graduated pipeline), Requirement 3 (configurable), Requirement 4 (pair invariants), Requirement 5 (dispatch masking), Requirement 6 (telemetry) | Success: (1) When masking alone is sufficient, summarization is skipped, (2) when masking is insufficient, summarization runs on already-masked messages, (3) when both fail, fallback runs, (4) observationMasking:false produces identical behavior to old code, (5) all existing tests pass, (6) telemetry fields populated correctly, (7) pair invariants maintained at every stage | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide. Do NOT start the next task until review is approved._\n\n- [ ] 5. Add comprehensive test coverage for graduated pipeline\n  - File: src/core/llm/history-reducer.test.ts\n  - Add tests for: masking-only sufficient, masking+summarization, full fallback, dispatch result detection, backward compat (observationMasking:false), telemetry accuracy, agent message preservation, pair invariant after masking\n  - Purpose: Ensure all reduction paths are tested and regression-proof\n  - _Leverage: src/core/llm/history-reducer.test.ts (existing tests as patterns), src/core/llm/history-reducer.ts_\n  - _Requirements: 1, 2, 3, 4, 5, 6_\n  - _Prompt: Implement the task for spec observation-masking, first call get-implementer-guide to load implementation rules then implement the task: Role: QA Engineer specializing in unit testing with Vitest | Task: Add comprehensive tests to src/core/llm/history-reducer.test.ts for the observation masking feature. Add a new describe block 'observation masking' with these test cases: (1) 'masks old observations while preserving agent actions' — create conversation with tool call/result pairs, verify only result messages outside window are masked while assistant messages preserved, (2) 'skips masking when observationMasking is false' — verify identical behavior to pre-masking reducer, (3) 'masking alone sufficient skips summarization' — verify reductionStage='masking' when masking brings context within budget, (4) 'falls through to summarization when masking insufficient' — verify reductionStage='summarization', (5) 'preserves dispatch result structured blocks' — create tool result with BEGIN/END_DISPATCH_RESULT, verify JSON block preserved, (6) 'populates maskedCount and maskedChars telemetry' — verify counts match expectations, (7) 'maintains pair invariants after masking' — verify masked messages keep pairId/pairRole/toolCallId, (8) 'uses maxObservationChars for placeholder length' — verify custom maxObservationChars respected. Use existing test patterns from the file. | Restrictions: Do NOT modify existing tests. Add new describe block after existing tests. Do NOT use mocks — test the real HistoryReducer. | _Leverage: src/core/llm/history-reducer.test.ts for test patterns and message factories | _Requirements: All requirements (comprehensive coverage) | Success: (1) All new tests pass, (2) all existing tests still pass, (3) each reduction stage has at least one test, (4) dispatch detection tested, (5) backward compatibility tested, (6) telemetry accuracy verified | Instructions: Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide. Do NOT start the next task until review is approved._\n",
  "fileStats": {
    "size": 13072,
    "lines": 50,
    "lastModified": "2026-02-06T03:31:30.646Z"
  },
  "comments": []
}