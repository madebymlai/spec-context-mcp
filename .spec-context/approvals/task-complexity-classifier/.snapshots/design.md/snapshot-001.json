{
  "id": "snapshot_1770480090741_eee7k2gm3",
  "approvalId": "approval_1770480090741_m6gyzp1du",
  "approvalTitle": "Design: Task-Complexity Classifier for CLI Agent Routing",
  "version": 1,
  "timestamp": "2026-02-07T16:01:30.741Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: Task-Complexity Classifier for CLI Agent Routing\n\n## Overview\n\nA proactive task-complexity classifier that evaluates dispatch tasks and routes them to the cheapest capable CLI agent. It sits between the orchestrator's `initRun` and the actual CLI dispatch, selecting the optimal provider from `PROVIDER_CATALOG` based on task features. The classifier is a pure, synchronous function behind a strategy interface — no LLM calls, no I/O.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- TypeScript, async-compatible interfaces (though classification itself is sync/pure)\n- Strategy pattern for swappable classifier implementations\n- Integration with existing `BudgetGuard` and `PROVIDER_CATALOG` infrastructure\n\n### Project Structure (structure.md)\n- New files under `src/core/routing/` — separate from `src/core/llm/` since routing is a distinct concern\n- Types co-located with implementation in `src/core/routing/types.ts`\n- Tests as sibling `.test.ts` files\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`PROVIDER_CATALOG`** (`src/config/discipline.ts`): Maps canonical providers to CLI commands per role. The routing table maps complexity tiers to entries in this catalog.\n- **`resolveAgentCli()`** (`src/config/discipline.ts`): Resolves provider name to CLI command. Router calls this with the selected provider.\n- **`BudgetGuard`** (`src/core/llm/budget-guard.ts`): Reactive budget enforcement. Runs *after* the classifier selects a provider — if budget denies the selection, the router escalates.\n- **`DispatchRuntimeManager.initRun()`** (`src/tools/workflow/dispatch-runtime.ts`): The integration point. Classification happens during or immediately after `initRun`, before `compilePrompt`.\n- **`StateSnapshotFact`** (`src/core/llm/types.ts`): Classification result stored as facts in the runtime snapshot for observability.\n\n### Integration Points\n- **`dispatch-runtime.ts`**: `initRun` gains a classification step. The selected provider is stored in the snapshot and used by `compilePrompt` to resolve the CLI command.\n- **`discipline.ts`**: Routing table configuration reads from env vars or defaults, following the same pattern as `SPEC_CONTEXT_DISCIPLINE`, `SPEC_CONTEXT_IMPLEMENTER`, etc.\n\n## Architecture\n\n```mermaid\ngraph TD\n    O[Orchestrator] -->|initRun| DR[DispatchRuntimeManager]\n    DR -->|task description + metadata| C[ITaskComplexityClassifier]\n    C -->|ClassificationResult| RT[RoutingTable]\n    RT -->|CanonicalProvider| DR\n    DR -->|compilePrompt with selected provider| CP[PromptPrefixCompiler]\n    DR -->|selected provider + role| RA[resolveAgentCli]\n    RA -->|CLI command| O\n    O -->|dispatch subprocess| CLI[CLI Agent]\n\n    BG[BudgetGuard] -.->|budget check on selected model| DR\n\n    style C fill:#e3f2fd\n    style RT fill:#e3f2fd\n```\n\n**Flow:**\n1. Orchestrator calls `initRun(runId, specName, taskId, projectPath)`\n2. `initRun` reads the task's `_Prompt` field from `tasks.md` to extract task description\n3. `ITaskComplexityClassifier.classify(taskInput)` returns `ClassificationResult`\n4. `RoutingTable.resolve(complexityLevel, role)` returns the `CanonicalProvider`\n5. Selected provider stored in snapshot facts\n6. `compilePrompt` uses the selected provider when assembling the dispatch\n7. Orchestrator reads the selected provider from the snapshot/response and passes it to `resolveAgentCli()` for the CLI command\n\n## Components and Interfaces\n\n### Component 1: ITaskComplexityClassifier (Interface)\n\n- **Purpose:** Classify a task's complexity from its description and metadata\n- **File:** `src/core/routing/types.ts`\n- **Interface:**\n  ```typescript\n  type ComplexityLevel = 'simple' | 'moderate' | 'complex';\n\n  interface TaskClassificationInput {\n    taskDescription: string;\n    fileCount?: number;\n    estimatedScope?: 'single-file' | 'multi-file' | 'cross-module';\n    taskId?: string;\n    specName?: string;\n    hints?: Record<string, string>;\n  }\n\n  interface ClassificationResult {\n    level: ComplexityLevel;\n    confidence: number;        // 0.0-1.0\n    features: ClassificationFeature[];\n    classifierId: string;      // which strategy produced this\n  }\n\n  interface ClassificationFeature {\n    name: string;\n    value: string | number | boolean;\n    weight: number;            // contribution to final score\n  }\n\n  interface ITaskComplexityClassifier {\n    classify(input: TaskClassificationInput): ClassificationResult;\n  }\n  ```\n- **Dependencies:** None (pure interface)\n\n### Component 2: HeuristicComplexityClassifier (Initial Implementation)\n\n- **Purpose:** Rule-based classifier using keyword/pattern matching on task description\n- **File:** `src/core/routing/heuristic-classifier.ts`\n- **Heuristic signals (scored and weighted):**\n\n  | Feature | Signal for `simple` | Signal for `complex` |\n  |---------|---------------------|---------------------|\n  | Keyword match | \"test stub\", \"rename\", \"doc update\", \"fix typo\", \"move file\", \"update import\" | \"refactor\", \"architect\", \"redesign\", \"new interface\", \"cross-module\" |\n  | File count hint | 1 file | 3+ files |\n  | Scope hint | `single-file` | `cross-module` |\n  | Description length | <100 chars | >500 chars |\n  | Action verb | \"add\", \"fix\", \"move\", \"rename\", \"update\" | \"implement\", \"design\", \"refactor\", \"integrate\" |\n\n- **Scoring:** Each feature contributes a weighted score. Thresholds map aggregate score to `ComplexityLevel`. Default bias: when ambiguous, classify as `complex` (safe default — misrouting complex tasks to weak agents is worse than the reverse).\n- **Dependencies:** `ITaskComplexityClassifier` interface\n- **Reuses:** Nothing — self-contained pure function\n\n### Component 3: RoutingTable\n\n- **Purpose:** Map `ComplexityLevel` to `CanonicalProvider` per `DispatchRole`\n- **File:** `src/core/routing/routing-table.ts`\n- **Interface:**\n  ```typescript\n  interface RoutingTableConfig {\n    simple: CanonicalProvider;\n    moderate: CanonicalProvider;\n    complex: CanonicalProvider;\n  }\n\n  interface RoutingTableEntry {\n    provider: CanonicalProvider;\n    cli: string;  // resolved CLI command\n  }\n\n  class RoutingTable {\n    constructor(config: RoutingTableConfig);\n    resolve(level: ComplexityLevel, role: DispatchRole): RoutingTableEntry;\n    static fromEnvOrDefault(): RoutingTable;\n  }\n  ```\n- **Default mapping:**\n  ```\n  simple   → codex    (cheapest, good for mechanical tasks)\n  moderate → claude   (mid-tier, handles multi-file well)\n  complex  → claude   (strongest available)\n  ```\n- **Configuration:** `SPEC_CONTEXT_ROUTE_SIMPLE`, `SPEC_CONTEXT_ROUTE_MODERATE`, `SPEC_CONTEXT_ROUTE_COMPLEX` env vars. Each accepts a provider name from `PROVIDER_CATALOG` or a custom command.\n- **Validation:** `fromEnvOrDefault()` validates all referenced providers exist in `PROVIDER_CATALOG`. Fails loud on invalid provider name.\n- **Dependencies:** `CanonicalProvider`, `DispatchRole`, `resolveAgentCli` from `discipline.ts`\n\n### Component 4: Integration into DispatchRuntimeManager\n\n- **Purpose:** Wire classifier + routing table into the dispatch lifecycle\n- **File:** `src/tools/workflow/dispatch-runtime.ts` (modification)\n- **Changes:**\n  1. `DispatchRuntimeManager` constructor accepts `ITaskComplexityClassifier` and `RoutingTable` via dependency injection\n  2. `initRun` extracts task description from the task's `_Prompt` field in `tasks.md`\n  3. After extracting progress/task ledgers, calls `classifier.classify()` with task metadata\n  4. Calls `routingTable.resolve()` to get the selected provider\n  5. Stores classification result + selected provider in snapshot facts:\n     ```\n     { k: 'classification_level', v: 'simple', confidence: 0.85 }\n     { k: 'selected_provider', v: 'codex', confidence: 1 }\n     { k: 'classification_features', v: '<json>', confidence: 1 }\n     ```\n  6. Returns the selected provider in the `initRun` response payload so the orchestrator knows which CLI to invoke\n- **BudgetGuard interaction:** BudgetGuard runs at the LLM provider level (`openrouter-chat.ts`), not at the CLI dispatch level. These are separate concerns — the classifier selects which CLI subprocess to spawn; BudgetGuard controls which LLM model that subprocess talks to internally. No direct integration needed at this layer.\n\n## Data Models\n\n### ClassificationResult\n```typescript\n{\n  level: 'simple' | 'moderate' | 'complex';\n  confidence: number;         // 0.0-1.0\n  features: {\n    name: string;             // e.g., 'keyword_match', 'file_count', 'description_length'\n    value: string | number | boolean;\n    weight: number;           // -1.0 to 1.0 contribution\n  }[];\n  classifierId: string;       // 'heuristic-v1'\n}\n```\n\n### RoutingTableConfig\n```typescript\n{\n  simple: CanonicalProvider;    // e.g., 'codex'\n  moderate: CanonicalProvider;  // e.g., 'claude'\n  complex: CanonicalProvider;   // e.g., 'claude'\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Classifier throws unexpected error**\n   - **Handling:** Catch, log, default to `{ level: 'complex', confidence: 0, features: [], classifierId: 'fallback' }`\n   - **User Impact:** Task routes to strongest agent — safe default, no degradation\n\n2. **Routing table references unknown provider**\n   - **Handling:** Fail loud at `RoutingTable.fromEnvOrDefault()` during startup\n   - **User Impact:** Server fails to start with clear error message identifying the bad provider name\n\n3. **Selected provider not configured for role**\n   - **Handling:** `RoutingTable.resolve()` validates provider exists in `PROVIDER_CATALOG` for the given role. Falls back to next tier up.\n   - **User Impact:** Task routes to stronger agent, logged as escalation\n\n## Testing Strategy\n\n### Unit Testing\n- **HeuristicComplexityClassifier:** Test each feature extractor independently. Test threshold boundaries. Test default-to-complex bias for ambiguous inputs.\n- **RoutingTable:** Test default config. Test env var override. Test validation failure on unknown provider. Test escalation on unavailable provider.\n- **Integration with initRun:** Mock classifier + routing table. Verify classification result stored in snapshot facts. Verify selected provider returned in response.\n\n### Integration Testing\n- Full `initRun` → classification → routing → `compilePrompt` flow with real task descriptions from existing specs\n- Verify the CLI command string matches expected provider output for each complexity level\n\n### Test Cases for Heuristic Classifier\n```\n\"Add test stub for UserService\"           → simple   (keyword: \"test stub\", single action)\n\"Fix typo in README.md\"                   → simple   (keyword: \"fix typo\", single file)\n\"Rename variable from foo to bar in utils\"→ simple   (keyword: \"rename\", single file)\n\"Implement OAuth2 flow with PKCE\"         → complex  (keyword: \"implement\", multi-concern)\n\"Refactor auth module to use strategy\"    → complex  (keyword: \"refactor\", \"strategy\")\n\"Add error handling to API endpoints\"     → moderate (scope ambiguous, multiple files possible)\n```\n",
  "fileStats": {
    "size": 10972,
    "lines": 228,
    "lastModified": "2026-02-07T16:01:26.259Z"
  },
  "comments": []
}