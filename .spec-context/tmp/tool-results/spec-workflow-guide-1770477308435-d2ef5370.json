{
  "guide": "# Spec Development Workflow\n\n## Overview\n\nYou guide users through spec-driven development using MCP tools. Transform rough ideas into detailed specifications through Requirements → Design → Tasks → Implementation phases. Use web search when available for current best practices (current year: 2026). Its important that you follow this workflow exactly to avoid errors.\nFeature names use kebab-case (e.g., user-authentication). Create ONE spec at a time.\n\n**Discipline Mode:** full\n- TDD required, code reviews enabled\n\n## Before Starting\n\n**Recap your understanding** of what the user wants to build, then ask:\n> \"Clear enough for spec, or brainstorm first?\"\n\nIf the idea needs refinement, use `get-brainstorm-guide` to explore before formal spec creation.\n\n## Workflow Diagram\n```mermaid\nflowchart TD\n    Start([Start: User requests feature]) --> CheckSteering{Steering docs exist?}\n    CheckSteering -->|Yes| P1_Load[Read steering docs:<br/>.spec-context/steering/*.md]\n    CheckSteering -->|No| P1_Template\n\n    %% Phase 1: Requirements\n    P1_Load --> P1_Template[Check user-templates first,<br/>then read template:<br/>requirements-template.md]\n    P1_Template --> P1_Research[Web search if available]\n    P1_Research --> P1_Create[Create file:<br/>.spec-context/specs/{name}/<br/>requirements.md]\n    P1_Create --> P1_Approve[approvals<br/>action: request<br/>filePath only]\n    P1_Approve --> P1_Wait[wait-for-approval<br/>blocks until resolved<br/>auto-deletes]\n    P1_Wait --> P1_Check{Status?}\n    P1_Check -->|needs-revision| P1_Update[Update document using user comments as guidance]\n    P1_Update --> P1_Approve\n    P1_Check -->|rejected| P1_Stop[Ask user for guidance]\n\n    %% Phase 2: Design\n    P1_Check -->|approved| P2_Template[Check user-templates first,<br/>then read template:<br/>design-template.md]\n    P2_Template --> P2_Analyze[Analyze codebase patterns]\n    P2_Analyze --> P2_Create[Create file:<br/>.spec-context/specs/{name}/<br/>design.md]\n    P2_Create --> P2_Approve[approvals<br/>action: request<br/>filePath only]\n    P2_Approve --> P2_Wait[wait-for-approval<br/>blocks until resolved<br/>auto-deletes]\n    P2_Wait --> P2_Check{Status?}\n    P2_Check -->|needs-revision| P2_Update[Update document using user comments as guidance]\n    P2_Update --> P2_Approve\n    P2_Check -->|rejected| P2_Stop[Ask user for guidance]\n\n    %% Phase 3: Tasks\n    P2_Check -->|approved| P3_Template[Check user-templates first,<br/>then read template:<br/>tasks-template.md]\n    P3_Template --> P3_Break[Convert design to tasks]\n    P3_Break --> P3_Create[Create file:<br/>.spec-context/specs/{name}/<br/>tasks.md]\n    P3_Create --> P3_Approve[approvals<br/>action: request<br/>filePath only]\n    P3_Approve --> P3_Wait[wait-for-approval<br/>blocks until resolved<br/>auto-deletes]\n    P3_Wait --> P3_Check{Status?}\n    P3_Check -->|needs-revision| P3_Update[Update document using user comments as guidance]\n    P3_Update --> P3_Approve\n    P3_Check -->|rejected| P3_Stop[Ask user for guidance]\n\n    %% Phase 4: Implementation (ONE task at a time)\n    P3_Check -->|approved| P4_Ready[Spec complete.<br/>Ready to implement?]\n    P4_Ready -->|Yes| P4_Pick[Pick ONE next pending task<br/>NEVER multiple]\n    P4_Pick --> P4_Dispatch[Dispatch to implementer:<br/>codex exec --full-auto]\n    P4_Dispatch --> P4_Verify[Verify: task marked [x],<br/>tests pass]\n    P4_Verify --> P4_Review{Reviews enabled?}\n    P4_Review -->|Yes| P4_DoReview[Dispatch to reviewer:<br/>codex exec --sandbox read-only]\n    P4_DoReview --> P4_ReviewResult{Review result?}\n    P4_ReviewResult -->|Issues found| P4_Fix[Dispatch implementer<br/>to fix issues]\n    P4_Fix --> P4_DoReview\n    P4_ReviewResult -->|Approved| P4_More{More tasks?}\n    P4_Review -->|No minimal mode| P4_More\n    P4_More -->|Yes| P4_Pick\n    P4_More -->|No| End([Implementation Complete])\n\n    style Start fill:#e1f5e1\n    style End fill:#e1f5e1\n    style P1_Check fill:#ffe6e6\n    style P2_Check fill:#ffe6e6\n    style P3_Check fill:#ffe6e6\n    style P1_Wait fill:#e3f2fd\n    style P2_Wait fill:#e3f2fd\n    style P3_Wait fill:#e3f2fd\n    style CheckSteering fill:#fff4e6\n    style P4_More fill:#fff4e6\n```\n\n## Spec Workflow\n\n### Phase 1: Requirements\n**Purpose**: Define what to build based on user needs.\n\n**File Operations**:\n- Read steering docs: `.spec-context/steering/*.md` (if they exist)\n- Check for custom template: `.spec-context/user-templates/requirements-template.md`\n- Read template: `.spec-context/templates/requirements-template.md` (if no custom template)\n- Create document: `.spec-context/specs/{spec-name}/requirements.md`\n\n**Tools**:\n- approvals: Create approval requests (action: request)\n- wait-for-approval: Block until user responds, auto-cleans up\n\n**Process**:\n1. Check if `.spec-context/steering/` exists (if yes, read product.md, tech.md, structure.md, principles.md)\n2. Check for custom template at `.spec-context/user-templates/requirements-template.md`\n3. If no custom template, read from `.spec-context/templates/requirements-template.md`\n4. Research market/user expectations (if web search available, current year: 2026)\n5. Generate requirements as user stories with EARS criteria\n6. Create `requirements.md` at `.spec-context/specs/{spec-name}/requirements.md`\n7. Request approval using approvals tool with action:'request' (filePath only, never content)\n8. Call wait-for-approval with the approvalId - this blocks until user responds and auto-deletes\n9. Handle result:\n   - approved: proceed to Phase 2\n   - needs-revision: update document with feedback, create NEW approval request, wait again\n   - rejected: STOP, ask user for guidance\n\n### Phase 2: Design\n**Purpose**: Create technical design addressing all requirements.\n\n**File Operations**:\n- Check for custom template: `.spec-context/user-templates/design-template.md`\n- Read template: `.spec-context/templates/design-template.md` (if no custom template)\n- Create document: `.spec-context/specs/{spec-name}/design.md`\n\n**Tools**:\n- approvals: Create approval requests (action: request)\n- wait-for-approval: Block until user responds, auto-cleans up\n\n**Process**:\n1. Check for custom template at `.spec-context/user-templates/design-template.md`\n2. If no custom template, read from `.spec-context/templates/design-template.md`\n3. Analyze codebase for patterns to reuse\n4. Research technology choices (if web search available, current year: 2026)\n5. Generate design with all template sections\n6. Create `design.md` at `.spec-context/specs/{spec-name}/design.md`\n7. Request approval using approvals tool with action:'request'\n8. Call wait-for-approval with the approvalId - this blocks until user responds and auto-deletes\n9. Handle result:\n   - approved: proceed to Phase 3\n   - needs-revision: update document with feedback, create NEW approval request, wait again\n   - rejected: STOP, ask user for guidance\n\n### Phase 3: Tasks\n**Purpose**: Break design into atomic implementation tasks.\n\n**File Operations**:\n- Check for custom template: `.spec-context/user-templates/tasks-template.md`\n- Read template: `.spec-context/templates/tasks-template.md` (if no custom template)\n- Create document: `.spec-context/specs/{spec-name}/tasks.md`\n\n**Tools**:\n- approvals: Create approval requests (action: request)\n- wait-for-approval: Block until user responds, auto-cleans up\n\n**Process**:\n1. Check for custom template at `.spec-context/user-templates/tasks-template.md`\n2. If no custom template, read from `.spec-context/templates/tasks-template.md`\n3. Convert design into atomic tasks (1-3 files each)\n4. Include file paths and requirement references\n5. **IMPORTANT**: Generate a _Prompt field for each task with:\n   - Role: specialized developer role for the task\n   - Task: clear description with context references\n   - Restrictions: what not to do, constraints to follow\n   - _Leverage: files/utilities to use\n   - _Requirements: requirements that the task implements\n   - Success: specific completion criteria\n   - Instructions: \"Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide.\"\n   - Start the prompt with \"Implement the task for spec {spec-name}, first call get-implementer-guide to load implementation rules then implement the task:\"\n6. Create `tasks.md` at `.spec-context/specs/{spec-name}/tasks.md`\n7. Request approval using approvals tool with action:'request'\n8. Call wait-for-approval with the approvalId - this blocks until user responds and auto-deletes\n9. Handle result:\n   - approved: \"Spec complete. Ready to implement?\"\n   - needs-revision: update document with feedback, create NEW approval request, wait again\n   - rejected: STOP, ask user for guidance\n\n### Phase 4: Implementation\n**Purpose**: Execute tasks ONE AT A TIME with TDD, verification, and review.\n\n**Agent Dispatch:**\n- Implementer CLI: `codex exec --full-auto`\n- Reviewer CLI: `codex exec --sandbox read-only`\n- You are the ORCHESTRATOR. You do NOT implement tasks yourself.\n- You DISPATCH each task to the implementer agent via bash.\n- You DISPATCH reviews to the reviewer agent via bash.\n\n**File Operations**:\n- Read tasks.md to check status and pick next task\n- Edit tasks.md to update status:\n  - `- [ ]` = Pending task\n  - `- [-]` = In-progress task (ONLY ONE at a time)\n  - `- [x]` = Completed task\n\n**Tools**:\n- spec-status: Check overall progress\n- dispatch-runtime: disabled (enable with SPEC_CONTEXT_DISPATCH_RUNTIME_V2=1)\n- Direct editing: Mark tasks as in-progress [-] or complete [x] in tasks.md\n- Bash: Dispatch tasks to implementer agent (`codex exec --full-auto`)\n- Bash: Dispatch reviews to reviewer agent (`codex exec --sandbox read-only`)\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  CRITICAL: ONE TASK AT A TIME                               ║\n║                                                              ║\n║  - NEVER mark multiple tasks as [-] in-progress              ║\n║  - NEVER start task N+1 before task N is [x] AND reviewed    ║\n║  - NEVER batch tasks together                                ║\n║  - Each task = implement → verify → review → THEN next       ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n**Process:**\n\n**Repeat for EACH task, sequentially:**\n\n1. **Pick ONE task**: Check spec-status, read tasks.md, identify the next pending `[ ]` task\n2. **Capture base SHA** (for reviewer later):\n   ```bash\n   git rev-parse HEAD\n   ```\n   Save this SHA — you'll pass it to the reviewer.\n3. **Build the task prompt**: Read the _Prompt field. Combine with:\n   - The spec name and task ID\n   - File paths from _Leverage fields\n   - Requirements from _Requirements fields\n   - Instructions to mark [-] before starting and [x] when done\n4. **Runtime v2 disabled**:\n   - Use legacy dispatch flow with minimal log inspection.\n5. **Dispatch to implementer agent via bash** (redirect output to log):\n   \n   ```bash\n   codex exec --full-auto \"Implement the task for spec {spec-name}, first call get-implementer-guide to load implementation rules then implement the task: {task prompt content}.\" > /tmp/spec-impl.log 2>&1\n   ```\n   - Implementer LAST output must be strict contract markers `BEGIN_DISPATCH_RESULT ... END_DISPATCH_RESULT`\n   - Wait for the command to complete before proceeding\n6. **Legacy result handling**:\n   - Runtime v2 disabled: use task markers and minimal diagnostics to decide next action.\n7. **Verify task completion**:\n   - Check tasks.md — task should now be [x].\n   - Get the diff (this is all you need to see):\n     ```bash\n     git diff {base-sha}..HEAD\n     ```\n8. **Review**:\n\n   ```bash\n   codex exec --sandbox read-only \"Review task {taskId} for spec {spec-name}. Base SHA: {base-sha}. Run: git diff {base-sha}..HEAD to see changes. Call get-reviewer-guide for review criteria. Check spec compliance, code quality, and principles. IMPORTANT: Your LAST output must be strict JSON contract from get-reviewer-guide.\" > /tmp/spec-review.log 2>&1\n   ```\n   - Runtime v2 disabled: evaluate reviewer verdict from final structured output manually\n   - If issues found: dispatch implementer again to fix, then re-review\n   - If approved: proceed to next task\n9. **Repeat from step 1** for the next pending task\n\n**CRITICAL rules:**\n- NEVER implement tasks yourself — always dispatch to `codex exec --full-auto`\n- NEVER dispatch multiple tasks at once — wait for each to complete\n- NEVER skip the review step\n- Runtime v2 disabled: keep log usage minimal and deterministic\n- If the implementer agent fails or produces bad output, dispatch it again with clearer instructions\n\n## Workflow Rules\n\n- Create documents directly at specified file paths\n- Read templates from `.spec-context/templates/` directory\n- Follow exact template structures\n- Get explicit user approval between phases using: approvals action:'request' → wait-for-approval\n- Complete phases in sequence (no skipping)\n- One spec at a time\n- Use kebab-case for spec names\n- Approval requests: provide filePath only, never content\n- wait-for-approval handles blocking AND cleanup automatically\n- CRITICAL: Verbal approval is NEVER accepted - dashboard only\n- NEVER proceed on user saying \"approved\" - use wait-for-approval tool\n- Steering docs are optional - only create when explicitly requested\n- **CRITICAL: ONE task at a time during implementation — never batch, never parallelize**\n- **CRITICAL: NEVER implement tasks yourself — always dispatch to `codex exec --full-auto`**\n- **CRITICAL: NEVER review tasks yourself — always dispatch to `codex exec --sandbox read-only`**\n\n## Implementation Review Workflow\n\n**MANDATORY after EACH task** (TDD + verification + review):\n\nFor EACH task:\n1. **Implement**: Dispatch to `codex exec --full-auto` via bash — agent calls `get-implementer-guide`, follows TDD rules, marks [x]\n   - Guide policy: call `get-implementer-guide` in `mode:\"full\"` once per run, then `mode:\"compact\"` on later tasks\n2. **Review**: Dispatch to `codex exec --sandbox read-only` via bash — check spec compliance, code quality, principles\n3. **Handle feedback:**\n   - If issues found: dispatch implementer again to fix, re-verify, dispatch reviewer again\n   - If same issue appears twice: orchestrator takes over (implementer doesn't understand)\n   - If approved: START the next task (go back to step 1)\n\n**NEVER start the next task before the current task is reviewed and approved.**\n**NEVER have more than one task marked [-] in-progress at any time.**\n**NEVER implement tasks yourself — always dispatch to `codex exec --full-auto`.**\n**NEVER review tasks yourself — always dispatch to `codex exec --sandbox read-only`.**\n\n## File Structure\n```\n.spec-context/\n├── templates/           # Auto-populated on server start\n│   ├── requirements-template.md\n│   ├── design-template.md\n│   ├── tasks-template.md\n│   ├── product-template.md\n│   ├── tech-template.md\n│   ├── structure-template.md\n│   └── principles-template.md\n├── specs/\n│   └── {spec-name}/\n│       ├── requirements.md\n│       ├── design.md\n│       └── tasks.md\n└── steering/\n    ├── product.md\n    ├── tech.md\n    ├── structure.md\n    └── principles.md\n```",
  "steering": {
    "principles": "# Aegis Trader - Coding Principles\n\n## SOLID Principles\n\n1. **Single Responsibility (SRP)** — One class, one reason to change\n   - Each class does exactly one job. If you're adding unrelated logic, create a new class.\n   - Ask: \"What is the single reason this class would need to change?\"\n   - Ask: \"Can I describe this class's purpose without using 'and'?\"\n\n2. **Open/Closed (OCP)** — Extend behavior without modifying existing code\n   - Add new implementations by creating new classes, not by editing existing ones.\n   - If adding a feature requires touching multiple files, the abstraction is wrong.\n   - Ask: \"Can I add this behavior without changing existing code?\"\n   - Ask: \"Am I editing a switch/if-else chain to add this?\"\n\n3. **Liskov Substitution (LSP)** — Implementations are interchangeable\n   - Any implementation of an interface must work anywhere that interface is used.\n   - Tests using mocks must behave identically to tests using real implementations.\n   - Ask: \"Would swapping this implementation break callers?\"\n   - Ask: \"Does this implementation honor all contracts of the interface?\"\n   - Ask: \"Am I using `isinstance` to decide behavior?\" (If yes, the abstraction is leaking)\n   - Ask: \"Am I casting/downcasting to a concrete type?\" (If yes, the interface is incomplete)\n\n4. **Interface Segregation (ISP)** — Small, focused interfaces\n   - Split large interfaces into smaller ones. No class should implement methods it doesn't need.\n   - If an implementation leaves methods empty or raises \"not supported\", the interface is too broad.\n   - Ask: \"Does this class use every method it's forced to implement?\"\n   - Ask: \"Would a new implementation need to stub out methods?\"\n\n5. **Dependency Inversion (DIP)** — Depend on abstractions\n   - Import interfaces, never concrete implementations.\n   - All external I/O (network, files, databases) must go through an interface.\n   - Wire implementations to abstractions in the DI container, nowhere else.\n   - Ask: \"Am I importing a concrete class or an interface?\"\n   - Ask: \"Can I swap this dependency without changing this file?\"\n\n## Additional Principles\n\n1. **No Defensive Garbage** — Let bugs surface, don't hide them\n   - No fallbacks for impossible cases. No `else` branches \"just in case.\"\n   - Trust your contracts - if something shouldn't happen, let it fail loud.\n   - Ask: \"Am I adding a fallback that hides bugs instead of surfacing them?\"\n   - Ask: \"Is this try/catch swallowing errors silently?\"\n   - Ask: \"Am I writing `if x is not None` everywhere instead of fixing the source?\"\n   - Ask: \"Does this 'safe' default make debugging impossible?\"\n   - Ask: \"Is this a dead branch that never executes but adds cognitive load?\"\n\n2. **KISS** — Simplest solution that works\n   - No cleverness for its own sake. Boring code is good code.\n   - Ask: \"Is there a simpler way to do this?\"\n   - Ask: \"Would a junior developer understand this immediately?\"\n\n3. **Domain is Pure** — No I/O in domain layer\n   - The `domain/` layer contains only entities, value objects, and business logic.\n   - Ask: \"Does this domain code import anything from infrastructure?\"\n   - Ask: \"Does this domain code do any I/O (network, files, database)?\"\n\n4. **DRY** — Extract repeated logic\n   - If you write the same logic twice, extract it.\n   - Ask: \"Have I written this pattern elsewhere in the codebase?\"\n   - Ask: \"Would changing this require updating multiple places?\"\n\n5. **Composition over Inheritance** — Combine behaviors, don't extend them\n   - Use decorators, aggregators, and delegation instead of class hierarchies.\n   - Ask: \"Am I inheriting just to reuse code?\" (Use composition instead)\n   - Ask: \"Is this class hierarchy deeper than 2 levels?\"\n\n6. **Async Everything** — All I/O uses async/await\n   - No blocking calls in async code paths.\n   - Ask: \"Is this I/O operation blocking the event loop?\"\n\n7. **Event-Driven** — Decouple via events\n   - Cross-component communication goes through `IEventBus`.\n   - Ask: \"Am I directly calling another component that doesn't need to know about me?\"\n\n8. **Make Invalid States Unrepresentable** — Model choices, not flag combinations\n   - Prefer a single enum/union over multiple booleans.\n   - Prefer table-driven dispatch over nested `if/elif`.\n   - Ask: \"Can this be expressed as one enum instead of multiple flags?\"\n   - Ask: \"Would adding a new variant require editing multiple conditionals?\"\n   - Ask: \"Is control flow compensating for a missing type/state model?\"\n\n9. **Tell, Don't Ask** — Move decisions to the object that owns the data\n   - Prefer `object.do()` over `if object.is_x(): ...`.\n   - Push branching into polymorphic implementations (strategy).\n   - Ask: \"Am I inspecting state to choose behavior instead of delegating?\"\n\n## Design Patterns\n\n1. **Fluent Interface**: For configuring objects with optional fields\n3. **Strategy Pattern**: Swappable algorithms via interfaces\n4. **Result Pattern** (Rust): Explicit error handling `Result<T, E>`\n5. **Replace Conditional with Polymorphism**: Move branching logic behind an interface; avoid type checks in callers\n"
  },
  "disciplineMode": "full",
  "dispatch": {
    "implementerCli": "codex exec --full-auto",
    "reviewerCli": "codex exec --sandbox read-only",
    "implementerConfigured": true,
    "reviewerConfigured": true
  },
  "dashboardUrl": "http://localhost:3000",
  "dashboardAvailable": true
}