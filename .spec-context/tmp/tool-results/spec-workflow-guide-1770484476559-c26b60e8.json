{
  "guide": "# Spec Development Workflow\n\n## Overview\n\nYou guide users through spec-driven development using MCP tools. Transform rough ideas into detailed specifications through Requirements → Design → Tasks → Implementation phases. Use web search when available for current best practices (current year: 2026). Its important that you follow this workflow exactly to avoid errors.\nFeature names use kebab-case (e.g., user-authentication). Create ONE spec at a time.\n\n**Discipline Mode:** full\n- TDD required, code reviews enabled\n\n## Before Starting\n\n**Recap your understanding** of what the user wants to build, then ask:\n> \"Clear enough for spec, or brainstorm first?\"\n\nIf the idea needs refinement, use `get-brainstorm-guide` to explore before formal spec creation.\n\n## Workflow Diagram\n```mermaid\nflowchart TD\n    Start([Start: User requests feature]) --> CheckSteering{Steering docs exist?}\n    CheckSteering -->|Yes| P1_Load[Read steering docs:<br/>.spec-context/steering/*.md]\n    CheckSteering -->|No| P1_Template\n\n    %% Phase 1: Requirements\n    P1_Load --> P1_Template[Use injected server template:<br/>requirements-template.md]\n    P1_Template --> P1_Research[Web search if available]\n    P1_Research --> P1_Create[Create file:<br/>.spec-context/specs/{name}/<br/>requirements.md]\n    P1_Create --> P1_Approve[approvals<br/>action: request<br/>filePath only]\n    P1_Approve --> P1_Wait[wait-for-approval<br/>blocks until resolved<br/>auto-deletes]\n    P1_Wait --> P1_Check{Status?}\n    P1_Check -->|needs-revision| P1_Update[Update document using user comments as guidance]\n    P1_Update --> P1_Approve\n    P1_Check -->|rejected| P1_Stop[Ask user for guidance]\n\n    %% Phase 2: Design\n    P1_Check -->|approved| P2_Template[Use injected server template:<br/>design-template.md]\n    P2_Template --> P2_Analyze[Analyze codebase patterns]\n    P2_Analyze --> P2_Create[Create file:<br/>.spec-context/specs/{name}/<br/>design.md]\n    P2_Create --> P2_Approve[approvals<br/>action: request<br/>filePath only]\n    P2_Approve --> P2_Wait[wait-for-approval<br/>blocks until resolved<br/>auto-deletes]\n    P2_Wait --> P2_Check{Status?}\n    P2_Check -->|needs-revision| P2_Update[Update document using user comments as guidance]\n    P2_Update --> P2_Approve\n    P2_Check -->|rejected| P2_Stop[Ask user for guidance]\n\n    %% Phase 3: Tasks\n    P2_Check -->|approved| P3_Template[Use injected server template:<br/>tasks-template.md]\n    P3_Template --> P3_Break[Convert design to tasks]\n    P3_Break --> P3_Create[Create file:<br/>.spec-context/specs/{name}/<br/>tasks.md]\n    P3_Create --> P3_Approve[approvals<br/>action: request<br/>filePath only]\n    P3_Approve --> P3_Wait[wait-for-approval<br/>blocks until resolved<br/>auto-deletes]\n    P3_Wait --> P3_Check{Status?}\n    P3_Check -->|needs-revision| P3_Update[Update document using user comments as guidance]\n    P3_Update --> P3_Approve\n    P3_Check -->|rejected| P3_Stop[Ask user for guidance]\n\n    %% Phase 4: Implementation (ONE task at a time)\n    P3_Check -->|approved| P4_Ready[Spec complete.<br/>Ready to implement?]\n    P4_Ready -->|Yes| P4_Pick[Pick ONE next pending task<br/>NEVER multiple]\n    P4_Pick --> P4_Dispatch[Dispatch to implementer:<br/>codex exec --full-auto]\n    P4_Dispatch --> P4_Verify[Verify: task marked [x],<br/>tests pass]\n    P4_Verify --> P4_Review{Reviews enabled?}\n    P4_Review -->|Yes| P4_DoReview[Dispatch to reviewer:<br/>codex exec --sandbox read-only]\n    P4_DoReview --> P4_ReviewResult{Review result?}\n    P4_ReviewResult -->|Issues found| P4_Fix[Dispatch implementer<br/>to fix issues]\n    P4_Fix --> P4_DoReview\n    P4_ReviewResult -->|Approved| P4_More{More tasks?}\n    P4_Review -->|No minimal mode| P4_More\n    P4_More -->|Yes| P4_Pick\n    P4_More -->|No| End([Implementation Complete])\n\n    style Start fill:#e1f5e1\n    style End fill:#e1f5e1\n    style P1_Check fill:#ffe6e6\n    style P2_Check fill:#ffe6e6\n    style P3_Check fill:#ffe6e6\n    style P1_Wait fill:#e3f2fd\n    style P2_Wait fill:#e3f2fd\n    style P3_Wait fill:#e3f2fd\n    style CheckSteering fill:#fff4e6\n    style P4_More fill:#fff4e6\n```\n\n## Spec Workflow\n\n### Phase 1: Requirements\n**Purpose**: Define what to build based on user needs.\n\n**File Operations**:\n- Use injected template payload from this tool response first: `data.templates.requirements`\n- Read steering docs: `.spec-context/steering/*.md` (if they exist)\n- Use server template: `requirements-template.md` from injected payload\n- Create document: `.spec-context/specs/{spec-name}/requirements.md`\n\n**Tools**:\n- approvals: Create approval requests (action: request)\n- wait-for-approval: Block until user responds, auto-cleans up\n\n**Process**:\n1. Check if `.spec-context/steering/` exists (if yes, read product.md, tech.md, structure.md, principles.md)\n2. Use `data.templates.requirements.content` from this tool response when available (includes resolved source + path)\n3. If `data.templates.requirements` is missing, stop and ask user to retry tool loading (no local template fallback)\n4. Research market/user expectations (if web search available, current year: 2026)\n5. Generate requirements as user stories with EARS criteria\n6. Create `requirements.md` at `.spec-context/specs/{spec-name}/requirements.md`\n7. Request approval using approvals tool with action:'request' (filePath only, never content)\n8. Call wait-for-approval with the approvalId - this blocks until user responds and auto-deletes\n9. Handle result:\n   - approved: proceed to Phase 2\n   - needs-revision: update document with feedback, create NEW approval request, wait again\n   - rejected: STOP, ask user for guidance\n\n### Phase 2: Design\n**Purpose**: Create technical design addressing all requirements.\n\n**File Operations**:\n- Use injected template payload from this tool response first: `data.templates.design`\n- Use server template: `design-template.md` from injected payload\n- Create document: `.spec-context/specs/{spec-name}/design.md`\n\n**Tools**:\n- approvals: Create approval requests (action: request)\n- wait-for-approval: Block until user responds, auto-cleans up\n\n**Process**:\n1. Use `data.templates.design.content` from this tool response when available (includes resolved source + path)\n2. If `data.templates.design` is missing, stop and ask user to retry tool loading (no local template fallback)\n3. Analyze codebase for patterns to reuse\n4. Research technology choices (if web search available, current year: 2026)\n5. Generate design with all template sections\n6. Create `design.md` at `.spec-context/specs/{spec-name}/design.md`\n7. Request approval using approvals tool with action:'request'\n8. Call wait-for-approval with the approvalId - this blocks until user responds and auto-deletes\n9. Handle result:\n   - approved: proceed to Phase 3\n   - needs-revision: update document with feedback, create NEW approval request, wait again\n   - rejected: STOP, ask user for guidance\n\n### Phase 3: Tasks\n**Purpose**: Break design into atomic implementation tasks.\n\n**File Operations**:\n- Use injected template payload from this tool response first: `data.templates.tasks`\n- Use server template: `tasks-template.md` from injected payload\n- Create document: `.spec-context/specs/{spec-name}/tasks.md`\n\n**Tools**:\n- approvals: Create approval requests (action: request)\n- wait-for-approval: Block until user responds, auto-cleans up\n\n**Process**:\n1. Use `data.templates.tasks.content` from this tool response when available (includes resolved source + path)\n2. If `data.templates.tasks` is missing, stop and ask user to retry tool loading (no local template fallback)\n3. Convert design into atomic tasks (1-3 files each)\n4. Include file paths and requirement references\n5. **IMPORTANT**: Generate a _Prompt field for each task with:\n   - Role: specialized developer role for the task\n   - Task: clear description with context references\n   - Restrictions: what not to do, constraints to follow\n   - _Leverage: files/utilities to use\n   - _Requirements: requirements that the task implements\n   - Success: specific completion criteria\n   - Instructions: \"Mark this ONE task as [-] in tasks.md before starting. Follow the loaded implementer guide rules (TDD required). When done, mark [x] in tasks.md. Then perform code review using the loaded reviewer guide.\"\n   - Start the prompt with \"Implement the task for spec {spec-name}, first call get-implementer-guide to load implementation rules then implement the task:\"\n6. Create `tasks.md` at `.spec-context/specs/{spec-name}/tasks.md`\n7. Request approval using approvals tool with action:'request'\n8. Call wait-for-approval with the approvalId - this blocks until user responds and auto-deletes\n9. Handle result:\n   - approved: \"Spec complete. Ready to implement?\"\n   - needs-revision: update document with feedback, create NEW approval request, wait again\n   - rejected: STOP, ask user for guidance\n\n### Phase 4: Implementation\n**Purpose**: Execute tasks ONE AT A TIME with TDD, verification, and review.\n\n**Agent Dispatch:**\n- Implementer CLI: `codex exec --full-auto`\n- Reviewer CLI: `codex exec --sandbox read-only`\n- You are the ORCHESTRATOR. You do NOT implement tasks yourself.\n- You DISPATCH each task to the implementer agent via bash.\n- You DISPATCH reviews to the reviewer agent via bash.\n\n**File Operations**:\n- Read tasks.md to check status and pick next task\n- Edit tasks.md to update status:\n  - `- [ ]` = Pending task\n  - `- [-]` = In-progress task (ONLY ONE at a time)\n  - `- [x]` = Completed task\n\n**Tools**:\n- spec-status: Check overall progress\n- dispatch-runtime: disabled (enable with SPEC_CONTEXT_DISPATCH_RUNTIME_V2=1)\n- Direct editing: Mark tasks as in-progress [-] or complete [x] in tasks.md\n- Bash: Dispatch tasks to implementer agent (`codex exec --full-auto`)\n- Bash: Dispatch reviews to reviewer agent (`codex exec --sandbox read-only`)\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  CRITICAL: ONE TASK AT A TIME                               ║\n║                                                              ║\n║  - NEVER mark multiple tasks as [-] in-progress              ║\n║  - NEVER start task N+1 before task N is [x] AND reviewed    ║\n║  - NEVER batch tasks together                                ║\n║  - Each task = implement → verify → review → THEN next       ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n**Process:**\n\n**Repeat for EACH task, sequentially:**\n\n1. **Pick ONE task**: Check spec-status, read tasks.md, identify the next pending `[ ]` task\n2. **Capture base SHA** (for reviewer later):\n   ```bash\n   git rev-parse HEAD\n   ```\n   Save this SHA — you'll pass it to the reviewer.\n3. **Build the task prompt**: Read the _Prompt field. Combine with:\n   - The spec name and task ID\n   - File paths from _Leverage fields\n   - Requirements from _Requirements fields\n   - Instructions to mark [-] before starting and [x] when done\n4. **Runtime v2 disabled**:\n   - Use legacy dispatch flow with minimal log inspection.\n5. **Dispatch to implementer agent via bash** (redirect output to log):\n   \n   ```bash\n   codex exec --full-auto \"Implement the task for spec {spec-name}, first call get-implementer-guide to load implementation rules then implement the task: {task prompt content}.\" > /tmp/spec-impl.log 2>&1\n   ```\n   - Implementer LAST output must be strict contract markers `BEGIN_DISPATCH_RESULT ... END_DISPATCH_RESULT`\n   - Wait for the command to complete before proceeding\n6. **Legacy result handling**:\n   - Runtime v2 disabled: use task markers and minimal diagnostics to decide next action.\n7. **Verify task completion**:\n   - Check tasks.md — task should now be [x].\n   - Get the diff (this is all you need to see):\n     ```bash\n     git diff {base-sha}..HEAD\n     ```\n8. **Review**:\n\n   ```bash\n   codex exec --sandbox read-only \"Review task {taskId} for spec {spec-name}. Base SHA: {base-sha}. Run: git diff {base-sha}..HEAD to see changes. Call get-reviewer-guide for review criteria. Check spec compliance, code quality, and principles. IMPORTANT: Your LAST output must be strict JSON contract from get-reviewer-guide.\" > /tmp/spec-review.log 2>&1\n   ```\n   - Runtime v2 disabled: evaluate reviewer verdict from final structured output manually\n   - If issues found: dispatch implementer again to fix, then re-review\n   - If approved: proceed to next task\n9. **Repeat from step 1** for the next pending task\n\n**CRITICAL rules:**\n- NEVER implement tasks yourself — always dispatch to `codex exec --full-auto`\n- NEVER dispatch multiple tasks at once — wait for each to complete\n- NEVER skip the review step\n- Runtime v2 disabled: keep log usage minimal and deterministic\n- If the implementer agent fails or produces bad output, dispatch it again with clearer instructions\n\n## Workflow Rules\n\n- Create documents directly at specified file paths\n- Use server-injected template payloads from this tool response\n- Follow exact template structures\n- Get explicit user approval between phases using: approvals action:'request' → wait-for-approval\n- Complete phases in sequence (no skipping)\n- One spec at a time\n- Use kebab-case for spec names\n- Approval requests: provide filePath only, never content\n- wait-for-approval handles blocking AND cleanup automatically\n- CRITICAL: Verbal approval is NEVER accepted - dashboard only\n- NEVER proceed on user saying \"approved\" - use wait-for-approval tool\n- Steering docs are optional - only create when explicitly requested\n- **CRITICAL: ONE task at a time during implementation — never batch, never parallelize**\n- **CRITICAL: NEVER implement tasks yourself — always dispatch to `codex exec --full-auto`**\n- **CRITICAL: NEVER review tasks yourself — always dispatch to `codex exec --sandbox read-only`**\n\n## Implementation Review Workflow\n\n**MANDATORY after EACH task** (TDD + verification + review):\n\nFor EACH task:\n1. **Implement**: Dispatch to `codex exec --full-auto` via bash — agent calls `get-implementer-guide`, follows TDD rules, marks [x]\n   - Guide policy: call `get-implementer-guide` in `mode:\"full\"` once per run, then `mode:\"compact\"` on later tasks\n2. **Review**: Dispatch to `codex exec --sandbox read-only` via bash — check spec compliance, code quality, principles\n3. **Handle feedback:**\n   - If issues found: dispatch implementer again to fix, re-verify, dispatch reviewer again\n   - If same issue appears twice: orchestrator takes over (implementer doesn't understand)\n   - If approved: START the next task (go back to step 1)\n\n**NEVER start the next task before the current task is reviewed and approved.**\n**NEVER have more than one task marked [-] in-progress at any time.**\n**NEVER implement tasks yourself — always dispatch to `codex exec --full-auto`.**\n**NEVER review tasks yourself — always dispatch to `codex exec --sandbox read-only`.**\n\n## File Structure\n```\n.spec-context/\n├── specs/\n│   └── {spec-name}/\n│       ├── requirements.md\n│       ├── design.md\n│       └── tasks.md\n└── steering/\n    ├── product.md\n    ├── tech.md\n    ├── structure.md\n    └── principles.md\n```\n\nTemplate files are server-bundled and injected into this tool response.",
  "steering": {
    "product": "# Product Overview\n\n## Product Purpose\n[Describe the core purpose of this product/project. What problem does it solve?]\n\n## Target Users\n[Who are the primary users of this product? What are their needs and pain points?]\n\n## Key Features\n[List the main features that deliver value to users]\n\n1. **Feature 1**: [Description]\n2. **Feature 2**: [Description]\n3. **Feature 3**: [Description]\n\n## Business Objectives\n[What are the business goals this product aims to achieve?]\n\n- [Objective 1]\n- [Objective 2]\n- [Objective 3]\n\n## Success Metrics\n[How will we measure the success of this product?]\n\n- [Metric 1]: [Target]\n- [Metric 2]: [Target]\n- [Metric 3]: [Target]\n\n## Product Principles\n[Core principles that guide product decisions]\n\n1. **[Principle 1]**: [Explanation]\n2. **[Principle 2]**: [Explanation]\n3. **[Principle 3]**: [Explanation]\n\n## Monitoring & Visibility (if applicable)\n[How do users track progress and monitor the system?]\n\n- **Dashboard Type**: [e.g., Web-based, CLI, Desktop app]\n- **Real-time Updates**: [e.g., WebSocket, polling, push notifications]\n- **Key Metrics Displayed**: [What information is most important to surface]\n- **Sharing Capabilities**: [e.g., read-only links, exports, reports]\n\n## Future Vision\n[Where do we see this product evolving in the future?]\n\n### Potential Enhancements\n- **Remote Access**: [e.g., Tunnel features for sharing dashboards with stakeholders]\n- **Analytics**: [e.g., Historical trends, performance metrics]\n- **Collaboration**: [e.g., Multi-user support, commenting]\n",
    "tech": "# Technology Stack\n\n> **Note:** Use the `search_code` tool to identify current technology patterns in the codebase. Search for import statements, configuration files, and common patterns.\n\n> **Note:** For coding standards and principles (SOLID, DRY, KISS, etc.), see `principles.md`.\n\n## Project Type\n[Describe what kind of project this is: web application, CLI tool, desktop application, mobile app, library, API service, embedded system, game, etc.]\n\n## Core Technologies\n\n### Primary Language(s)\n- **Language**: [e.g., Python 3.11, Go 1.21, TypeScript, Rust, C++]\n- **Runtime/Compiler**: [if applicable]\n- **Language-specific tools**: [package managers, build tools, etc.]\n\n### Key Dependencies/Libraries\n[List the main libraries and frameworks your project depends on]\n- **[Library/Framework name]**: [Purpose and version]\n- **[Library/Framework name]**: [Purpose and version]\n\n### Application Architecture\n[Describe how your application is structured - this could be MVC, event-driven, plugin-based, client-server, standalone, microservices, monolithic, etc.]\n\n### Data Storage (if applicable)\n- **Primary storage**: [e.g., PostgreSQL, files, in-memory, cloud storage]\n- **Caching**: [e.g., Redis, in-memory, disk cache]\n- **Data formats**: [e.g., JSON, Protocol Buffers, XML, binary]\n\n### External Integrations (if applicable)\n- **APIs**: [External services you integrate with]\n- **Protocols**: [e.g., HTTP/REST, gRPC, WebSocket, TCP/IP]\n- **Authentication**: [e.g., OAuth, API keys, certificates]\n\n### Monitoring & Dashboard Technologies (if applicable)\n- **Dashboard Framework**: [e.g., React, Vue, vanilla JS, terminal UI]\n- **Real-time Communication**: [e.g., WebSocket, Server-Sent Events, polling]\n- **Visualization Libraries**: [e.g., Chart.js, D3, terminal graphs]\n- **State Management**: [e.g., Redux, Vuex, file system as source of truth]\n\n## Development Environment\n\n### Build & Development Tools\n- **Build System**: [e.g., Make, CMake, Gradle, npm scripts, cargo]\n- **Package Management**: [e.g., pip, npm, cargo, go mod, apt, brew]\n- **Development workflow**: [e.g., hot reload, watch mode, REPL]\n\n### Code Quality Tools\n- **Static Analysis**: [Tools for code quality and correctness]\n- **Formatting**: [Code style enforcement tools]\n- **Testing Framework**: [Unit, integration, and/or end-to-end testing tools]\n- **Documentation**: [Documentation generation tools]\n\n### Version Control & Collaboration\n- **VCS**: [e.g., Git, Mercurial, SVN]\n- **Branching Strategy**: [e.g., Git Flow, GitHub Flow, trunk-based]\n- **Code Review Process**: [How code reviews are conducted]\n\n### Dashboard Development (if applicable)\n- **Live Reload**: [e.g., Hot module replacement, file watchers]\n- **Port Management**: [e.g., Dynamic allocation, configurable ports]\n- **Multi-Instance Support**: [e.g., Running multiple dashboards simultaneously]\n\n## Deployment & Distribution (if applicable)\n- **Target Platform(s)**: [Where/how the project runs: cloud, on-premise, desktop, mobile, embedded]\n- **Distribution Method**: [How users get your software: download, package manager, app store, SaaS]\n- **Installation Requirements**: [Prerequisites, system requirements]\n- **Update Mechanism**: [How updates are delivered]\n\n## Technical Requirements & Constraints\n\n### Performance Requirements\n- [e.g., response time, throughput, memory usage, startup time]\n- [Specific benchmarks or targets]\n\n### Compatibility Requirements  \n- **Platform Support**: [Operating systems, architectures, versions]\n- **Dependency Versions**: [Minimum/maximum versions of dependencies]\n- **Standards Compliance**: [Industry standards, protocols, specifications]\n\n### Security & Compliance\n- **Security Requirements**: [Authentication, encryption, data protection]\n- **Compliance Standards**: [GDPR, HIPAA, SOC2, etc. if applicable]\n- **Threat Model**: [Key security considerations]\n\n### Scalability & Reliability\n- **Expected Load**: [Users, requests, data volume]\n- **Availability Requirements**: [Uptime targets, disaster recovery]\n- **Growth Projections**: [How the system needs to scale]\n\n## Technical Decisions & Rationale\n[Document key architectural and technology choices]\n\n### Decision Log\n1. **[Technology/Pattern Choice]**: [Why this was chosen, alternatives considered]\n2. **[Architecture Decision]**: [Rationale, trade-offs accepted]\n3. **[Tool/Library Selection]**: [Reasoning, evaluation criteria]\n\n## Known Limitations\n[Document any technical debt, limitations, or areas for improvement]\n\n- [Limitation 1]: [Impact and potential future solutions]\n- [Limitation 2]: [Why it exists and when it might be addressed]\n",
    "structure": "# Project Structure\n\n> **Note:** Use the `search_code` tool to discover the actual codebase structure before documenting. This ensures the structure document reflects reality.\n\n## Directory Organization\n\n```\n[Define your project's directory structure. Examples below - adapt to your project type]\n\nExample for a library/package:\nproject-root/\n├── src/                    # Source code\n├── tests/                  # Test files  \n├── docs/                   # Documentation\n├── examples/               # Usage examples\n└── [build/dist/out]        # Build output\n\nExample for an application:\nproject-root/\n├── [src/app/lib]           # Main source code\n├── [assets/resources]      # Static resources\n├── [config/settings]       # Configuration\n├── [scripts/tools]         # Build/utility scripts\n└── [tests/spec]            # Test files\n\nCommon patterns:\n- Group by feature/module\n- Group by layer (UI, business logic, data)\n- Group by type (models, controllers, views)\n- Flat structure for simple projects\n```\n\n## Naming Conventions\n\n### Files\n\n* **Components/Modules**: \\[e.g., `PascalCase`, `snake_case`, `kebab-case`]\n* **Services/Handlers**: \\[e.g., `UserService`, `user_service`, `user-service`]\n* **Utilities/Helpers**: \\[e.g., `dateUtils`, `date_utils`, `date-utils`]\n* **Tests**: \\[e.g., `[filename]_test`, `[filename].test`, `[filename]Test`]\n\n### Code\n\n* **Classes/Types**: \\[e.g., `PascalCase`, `CamelCase`, `snake_case`]\n* **Functions/Methods**: \\[e.g., `camelCase`, `snake_case`, `PascalCase`]\n* **Constants**: \\[e.g., `UPPER_SNAKE_CASE`, `SCREAMING_CASE`, `PascalCase`]\n* **Variables**: \\[e.g., `camelCase`, `snake_case`, `lowercase`]\n\n## Import Patterns\n\n### Import Order\n\n1. External dependencies\n2. Internal modules\n3. Relative imports\n4. Style imports\n\n### Module/Package Organization\n\n```\n[Describe your project's import/include patterns]\nExamples:\n- Absolute imports from project root\n- Relative imports within modules\n- Package/namespace organization\n- Dependency management approach\n```\n\n## Code Structure Patterns\n\n\\[Define common patterns for organizing code within files. Below are examples - choose what applies to your project]\n\n### Module/Class Organization\n\n```\nExample patterns:\n1. Imports/includes/dependencies\n2. Constants and configuration\n3. Type/interface definitions\n4. Main implementation\n5. Helper/utility functions\n6. Exports/public API\n```\n\n### Function/Method Organization\n\n```\nExample patterns:\n- Input validation first\n- Core logic in the middle\n- Error handling throughout\n- Clear return points\n```\n\n### File Organization Principles\n\n```\nChoose what works for your project:\n- One class/module per file\n- Related functionality grouped together\n- Public API at the top/bottom\n- Implementation details hidden\n```\n\n## Module Boundaries\n\n\\[Define how different parts of your project interact and maintain separation of concerns]\n\nExamples of boundary patterns:\n\n* **Core vs Plugins**: Core functionality vs extensible plugins\n* **Public API vs Internal**: What's exposed vs implementation details\n* **Platform-specific vs Cross-platform**: OS-specific code isolation\n* **Stable vs Experimental**: Production code vs experimental features\n* **Dependencies direction**: Which modules can depend on which\n\n## Code Size Guidelines\n\n\\[Define your project's guidelines for file and function sizes]\n\nSuggested guidelines:\n\n* **File size**: \\[Define maximum lines per file]\n* **Function/Method size**: \\[Define maximum lines per function]\n* **Class/Module complexity**: \\[Define complexity limits]\n* **Nesting depth**: \\[Maximum nesting levels]\n\n## Dashboard/Monitoring Structure (if applicable)\n\n\\[How dashboard or monitoring components are organized]\n\n### Example Structure:\n\n```\nsrc/\n└── dashboard/          # Self-contained dashboard subsystem\n    ├── server/        # Backend server components\n    ├── client/        # Frontend assets\n    ├── shared/        # Shared types/utilities\n    └── public/        # Static assets\n```\n\n### Separation of Concerns\n\n* Dashboard isolated from core business logic\n* Own CLI entry point for independent operation\n* Minimal dependencies on main application\n* Can be disabled without affecting core functionality\n\n## Documentation Standards\n\n* All public APIs must have documentation\n* Complex logic should include inline comments\n* README files for major modules\n* Follow language-specific documentation conventions",
    "principles": "# Aegis Trader - Coding Principles\n\n## SOLID Principles\n\n1. **Single Responsibility (SRP)** — One class, one reason to change\n   - Each class does exactly one job. If you're adding unrelated logic, create a new class.\n   - Ask: \"What is the single reason this class would need to change?\"\n   - Ask: \"Can I describe this class's purpose without using 'and'?\"\n\n2. **Open/Closed (OCP)** — Extend behavior without modifying existing code\n   - Add new implementations by creating new classes, not by editing existing ones.\n   - If adding a feature requires touching multiple files, the abstraction is wrong.\n   - Ask: \"Can I add this behavior without changing existing code?\"\n   - Ask: \"Am I editing a switch/if-else chain to add this?\"\n\n3. **Liskov Substitution (LSP)** — Implementations are interchangeable\n   - Any implementation of an interface must work anywhere that interface is used.\n   - Tests using mocks must behave identically to tests using real implementations.\n   - Ask: \"Would swapping this implementation break callers?\"\n   - Ask: \"Does this implementation honor all contracts of the interface?\"\n   - Ask: \"Am I using `isinstance` to decide behavior?\" (If yes, the abstraction is leaking)\n   - Ask: \"Am I casting/downcasting to a concrete type?\" (If yes, the interface is incomplete)\n\n4. **Interface Segregation (ISP)** — Small, focused interfaces\n   - Split large interfaces into smaller ones. No class should implement methods it doesn't need.\n   - If an implementation leaves methods empty or raises \"not supported\", the interface is too broad.\n   - Ask: \"Does this class use every method it's forced to implement?\"\n   - Ask: \"Would a new implementation need to stub out methods?\"\n\n5. **Dependency Inversion (DIP)** — Depend on abstractions\n   - Import interfaces, never concrete implementations.\n   - All external I/O (network, files, databases) must go through an interface.\n   - Wire implementations to abstractions in the DI container, nowhere else.\n   - Ask: \"Am I importing a concrete class or an interface?\"\n   - Ask: \"Can I swap this dependency without changing this file?\"\n\n## Additional Principles\n\n1. **No Defensive Garbage** — Let bugs surface, don't hide them\n   - No fallbacks for impossible cases. No `else` branches \"just in case.\"\n   - Trust your contracts - if something shouldn't happen, let it fail loud.\n   - Ask: \"Am I adding a fallback that hides bugs instead of surfacing them?\"\n   - Ask: \"Is this try/catch swallowing errors silently?\"\n   - Ask: \"Am I writing `if x is not None` everywhere instead of fixing the source?\"\n   - Ask: \"Does this 'safe' default make debugging impossible?\"\n   - Ask: \"Is this a dead branch that never executes but adds cognitive load?\"\n\n2. **KISS** — Simplest solution that works\n   - No cleverness for its own sake. Boring code is good code.\n   - Ask: \"Is there a simpler way to do this?\"\n   - Ask: \"Would a junior developer understand this immediately?\"\n\n3. **Domain is Pure** — No I/O in domain layer\n   - The `domain/` layer contains only entities, value objects, and business logic.\n   - Ask: \"Does this domain code import anything from infrastructure?\"\n   - Ask: \"Does this domain code do any I/O (network, files, database)?\"\n\n4. **DRY** — Extract repeated logic\n   - If you write the same logic twice, extract it.\n   - Ask: \"Have I written this pattern elsewhere in the codebase?\"\n   - Ask: \"Would changing this require updating multiple places?\"\n\n5. **Composition over Inheritance** — Combine behaviors, don't extend them\n   - Use decorators, aggregators, and delegation instead of class hierarchies.\n   - Ask: \"Am I inheriting just to reuse code?\" (Use composition instead)\n   - Ask: \"Is this class hierarchy deeper than 2 levels?\"\n\n6. **Async Everything** — All I/O uses async/await\n   - No blocking calls in async code paths.\n   - Ask: \"Is this I/O operation blocking the event loop?\"\n\n7. **Event-Driven** — Decouple via events\n   - Cross-component communication goes through `IEventBus`.\n   - Ask: \"Am I directly calling another component that doesn't need to know about me?\"\n\n8. **Make Invalid States Unrepresentable** — Model choices, not flag combinations\n   - Prefer a single enum/union over multiple booleans.\n   - Prefer table-driven dispatch over nested `if/elif`.\n   - Ask: \"Can this be expressed as one enum instead of multiple flags?\"\n   - Ask: \"Would adding a new variant require editing multiple conditionals?\"\n   - Ask: \"Is control flow compensating for a missing type/state model?\"\n\n9. **Tell, Don't Ask** — Move decisions to the object that owns the data\n   - Prefer `object.do()` over `if object.is_x(): ...`.\n   - Push branching into polymorphic implementations (strategy).\n   - Ask: \"Am I inspecting state to choose behavior instead of delegating?\"\n\n## Design Patterns\n\n1. **Fluent Interface**: For configuring objects with optional fields\n3. **Strategy Pattern**: Swappable algorithms via interfaces\n4. **Result Pattern** (Rust): Explicit error handling `Result<T, E>`\n5. **Replace Conditional with Polymorphism**: Move branching logic behind an interface; avoid type checks in callers\n"
  },
  "templates": {
    "requirements": {
      "content": "# Requirements Document\n\n## Introduction\n\n[Provide a brief overview of the feature, its purpose, and its value to users]\n\n## Alignment with Product Vision\n\n[Explain how this feature supports the goals outlined in product.md]\n\n## Requirements\n\n### Requirement 1\n\n**User Story:** As a [role], I want [feature], so that [benefit]\n\n#### Acceptance Criteria\n\n1. WHEN [event] THEN [system] SHALL [response]\n2. IF [precondition] THEN [system] SHALL [response]\n3. WHEN [event] AND [condition] THEN [system] SHALL [response]\n\n### Requirement 2\n\n**User Story:** As a [role], I want [feature], so that [benefit]\n\n#### Acceptance Criteria\n\n1. WHEN [event] THEN [system] SHALL [response]\n2. IF [precondition] THEN [system] SHALL [response]\n\n## Non-Functional Requirements\n\n> **Note:** Use the `search_code` tool to understand existing patterns before defining NFRs. This ensures requirements align with the current codebase architecture.\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: Each file should have a single, well-defined purpose\n- **Modular Design**: Components, utilities, and services should be isolated and reusable\n- **Dependency Management**: Minimize interdependencies between modules\n- **Clear Interfaces**: Define clean contracts between components and layers\n\n### Performance\n- [Performance requirements]\n\n### Security\n- [Security requirements]\n\n### Reliability\n- [Reliability requirements]\n\n### Usability\n- [Usability requirements]\n",
      "source": "server",
      "path": "/home/laimk/git/spec-context-mcp/dist/templates/requirements-template.md"
    },
    "design": {
      "content": "# Design Document\n\n## Overview\n\n[High-level description of the feature and its place in the overall system]\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n[How the design follows documented technical patterns and standards]\n\n### Project Structure (structure.md)\n[How the implementation will follow project organization conventions]\n\n## Code Reuse Analysis\n\n> **Note:** Use the `search_code` tool to find existing components for this section. Search for related functionality, similar patterns, and reusable utilities.\n\n[What existing code will be leveraged, extended, or integrated with this feature]\n\n### Existing Components to Leverage\n- **[Component/Utility Name]**: [How it will be used]\n- **[Service/Helper Name]**: [How it will be extended]\n\n### Integration Points\n- **[Existing System/API]**: [How the new feature will integrate]\n- **[Database/Storage]**: [How data will connect to existing schemas]\n\n## Architecture\n\n[Describe the overall architecture and design patterns used]\n\n### Modular Design Principles\n- **Single File Responsibility**: Each file should handle one specific concern or domain\n- **Component Isolation**: Create small, focused components rather than large monolithic files\n- **Service Layer Separation**: Separate data access, business logic, and presentation layers\n- **Utility Modularity**: Break utilities into focused, single-purpose modules\n\n```mermaid\ngraph TD\n    A[Component A] --> B[Component B]\n    B --> C[Component C]\n```\n\n## Components and Interfaces\n\n### Component 1\n- **Purpose:** [What this component does]\n- **Interfaces:** [Public methods/APIs]\n- **Dependencies:** [What it depends on]\n- **Reuses:** [Existing components/utilities it builds upon]\n\n### Component 2\n- **Purpose:** [What this component does]\n- **Interfaces:** [Public methods/APIs]\n- **Dependencies:** [What it depends on]\n- **Reuses:** [Existing components/utilities it builds upon]\n\n## Data Models\n\n### Model 1\n```\n[Define the structure of Model1 in your language]\n- id: [unique identifier type]\n- name: [string/text type]\n- [Additional properties as needed]\n```\n\n### Model 2\n```\n[Define the structure of Model2 in your language]\n- id: [unique identifier type]\n- [Additional properties as needed]\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Scenario 1:** [Description]\n   - **Handling:** [How to handle]\n   - **User Impact:** [What user sees]\n\n2. **Scenario 2:** [Description]\n   - **Handling:** [How to handle]\n   - **User Impact:** [What user sees]\n\n## Testing Strategy\n\n### Unit Testing\n- [Unit testing approach]\n- [Key components to test]\n\n### Integration Testing\n- [Integration testing approach]\n- [Key flows to test]\n\n### End-to-End Testing\n- [E2E testing approach]\n- [User scenarios to test]\n",
      "source": "server",
      "path": "/home/laimk/git/spec-context-mcp/dist/templates/design-template.md"
    },
    "tasks": {
      "content": "# Tasks Document\n\n> **Note:** Use the `search_code` tool to populate `_Leverage:` fields with actual file paths from the codebase.\n\n- [ ] 1. Create core interfaces in src/types/feature.ts\n  - File: src/types/feature.ts\n  - Define TypeScript interfaces for feature data structures\n  - Extend existing base interfaces from base.ts\n  - Purpose: Establish type safety for feature implementation\n  - _Leverage: src/types/base.ts_\n  - _Requirements: 1.1_\n  - _Prompt: Role: TypeScript Developer specializing in type systems and interfaces | Task: Create comprehensive TypeScript interfaces for the feature data structures following requirements 1.1, extending existing base interfaces from src/types/base.ts | Restrictions: Do not modify existing base interfaces, maintain backward compatibility, follow project naming conventions | Success: All interfaces compile without errors, proper inheritance from base types, full type coverage for feature requirements | Instructions: Mark this ONE task [-] before starting. Follow loaded implementer guide (TDD in full mode). Mark [x] when done. Review using loaded reviewer guide. Do NOT start next task until review approved._\n\n- [ ] 2. Create base model class in src/models/FeatureModel.ts\n  - File: src/models/FeatureModel.ts\n  - Implement base model extending BaseModel class\n  - Add validation methods using existing validation utilities\n  - Purpose: Provide data layer foundation for feature\n  - _Leverage: src/models/BaseModel.ts, src/utils/validation.ts_\n  - _Requirements: 2.1_\n  - _Prompt: Role: Backend Developer with expertise in Node.js and data modeling | Task: Create a base model class extending BaseModel and implementing validation following requirement 2.1, leveraging existing patterns from src/models/BaseModel.ts and src/utils/validation.ts | Restrictions: Must follow existing model patterns, do not bypass validation utilities, maintain consistent error handling | Success: Model extends BaseModel correctly, validation methods implemented and tested, follows project architecture patterns_\n\n- [ ] 3. Add specific model methods to FeatureModel.ts\n  - File: src/models/FeatureModel.ts (continue from task 2)\n  - Implement create, update, delete methods\n  - Add relationship handling for foreign keys\n  - Purpose: Complete model functionality for CRUD operations\n  - _Leverage: src/models/BaseModel.ts_\n  - _Requirements: 2.2, 2.3_\n  - _Prompt: Role: Backend Developer with expertise in ORM and database operations | Task: Implement CRUD methods and relationship handling in FeatureModel.ts following requirements 2.2 and 2.3, extending patterns from src/models/BaseModel.ts | Restrictions: Must maintain transaction integrity, follow existing relationship patterns, do not duplicate base model functionality | Success: All CRUD operations work correctly, relationships are properly handled, database operations are atomic and efficient_\n\n- [ ] 4. Create model unit tests in tests/models/FeatureModel.test.ts\n  - File: tests/models/FeatureModel.test.ts\n  - Write tests for model validation and CRUD methods\n  - Use existing test utilities and fixtures\n  - Purpose: Ensure model reliability and catch regressions\n  - _Leverage: tests/helpers/testUtils.ts, tests/fixtures/data.ts_\n  - _Requirements: 2.1, 2.2_\n  - _Prompt: Role: QA Engineer with expertise in unit testing and Jest/Mocha frameworks | Task: Create comprehensive unit tests for FeatureModel validation and CRUD methods covering requirements 2.1 and 2.2, using existing test utilities from tests/helpers/testUtils.ts and fixtures from tests/fixtures/data.ts | Restrictions: Must test both success and failure scenarios, do not test external dependencies directly, maintain test isolation | Success: All model methods are tested with good coverage, edge cases covered, tests run independently and consistently_\n\n- [ ] 5. Create service interface in src/services/IFeatureService.ts\n  - File: src/services/IFeatureService.ts\n  - Define service contract with method signatures\n  - Extend base service interface patterns\n  - Purpose: Establish service layer contract for dependency injection\n  - _Leverage: src/services/IBaseService.ts_\n  - _Requirements: 3.1_\n  - _Prompt: Role: Software Architect specializing in service-oriented architecture and TypeScript interfaces | Task: Design service interface contract following requirement 3.1, extending base service patterns from src/services/IBaseService.ts for dependency injection | Restrictions: Must maintain interface segregation principle, do not expose internal implementation details, ensure contract compatibility with DI container | Success: Interface is well-defined with clear method signatures, extends base service appropriately, supports all required service operations_\n\n- [ ] 6. Implement feature service in src/services/FeatureService.ts\n  - File: src/services/FeatureService.ts\n  - Create concrete service implementation using FeatureModel\n  - Add error handling with existing error utilities\n  - Purpose: Provide business logic layer for feature operations\n  - _Leverage: src/services/BaseService.ts, src/utils/errorHandler.ts, src/models/FeatureModel.ts_\n  - _Requirements: 3.2_\n  - _Prompt: Role: Backend Developer with expertise in service layer architecture and business logic | Task: Implement concrete FeatureService following requirement 3.2, using FeatureModel and extending BaseService patterns with proper error handling from src/utils/errorHandler.ts | Restrictions: Must implement interface contract exactly, do not bypass model validation, maintain separation of concerns from data layer | Success: Service implements all interface methods correctly, robust error handling implemented, business logic is well-encapsulated and testable_\n\n- [ ] 7. Add service dependency injection in src/utils/di.ts\n  - File: src/utils/di.ts (modify existing)\n  - Register FeatureService in dependency injection container\n  - Configure service lifetime and dependencies\n  - Purpose: Enable service injection throughout application\n  - _Leverage: existing DI configuration in src/utils/di.ts_\n  - _Requirements: 3.1_\n  - _Prompt: Role: DevOps Engineer with expertise in dependency injection and IoC containers | Task: Register FeatureService in DI container following requirement 3.1, configuring appropriate lifetime and dependencies using existing patterns from src/utils/di.ts | Restrictions: Must follow existing DI container patterns, do not create circular dependencies, maintain service resolution efficiency | Success: FeatureService is properly registered and resolvable, dependencies are correctly configured, service lifetime is appropriate for use case_\n\n- [ ] 8. Create service unit tests in tests/services/FeatureService.test.ts\n  - File: tests/services/FeatureService.test.ts\n  - Write tests for service methods with mocked dependencies\n  - Test error handling scenarios\n  - Purpose: Ensure service reliability and proper error handling\n  - _Leverage: tests/helpers/testUtils.ts, tests/mocks/modelMocks.ts_\n  - _Requirements: 3.2, 3.3_\n  - _Prompt: Role: QA Engineer with expertise in service testing and mocking frameworks | Task: Create comprehensive unit tests for FeatureService methods covering requirements 3.2 and 3.3, using mocked dependencies from tests/mocks/modelMocks.ts and test utilities | Restrictions: Must mock all external dependencies, test business logic in isolation, do not test framework code | Success: All service methods tested with proper mocking, error scenarios covered, tests verify business logic correctness and error handling_\n\n- [ ] 4. Create API endpoints\n  - Design API structure\n  - _Leverage: src/api/baseApi.ts, src/utils/apiUtils.ts_\n  - _Requirements: 4.0_\n  - _Prompt: Role: API Architect specializing in RESTful design and Express.js | Task: Design comprehensive API structure following requirement 4.0, leveraging existing patterns from src/api/baseApi.ts and utilities from src/utils/apiUtils.ts | Restrictions: Must follow REST conventions, maintain API versioning compatibility, do not expose internal data structures directly | Success: API structure is well-designed and documented, follows existing patterns, supports all required operations with proper HTTP methods and status codes_\n\n- [ ] 4.1 Set up routing and middleware\n  - Configure application routes\n  - Add authentication middleware\n  - Set up error handling middleware\n  - _Leverage: src/middleware/auth.ts, src/middleware/errorHandler.ts_\n  - _Requirements: 4.1_\n  - _Prompt: Role: Backend Developer with expertise in Express.js middleware and routing | Task: Configure application routes and middleware following requirement 4.1, integrating authentication from src/middleware/auth.ts and error handling from src/middleware/errorHandler.ts | Restrictions: Must maintain middleware order, do not bypass security middleware, ensure proper error propagation | Success: Routes are properly configured with correct middleware chain, authentication works correctly, errors are handled gracefully throughout the request lifecycle_\n\n- [ ] 4.2 Implement CRUD endpoints\n  - Create API endpoints\n  - Add request validation\n  - Write API integration tests\n  - _Leverage: src/controllers/BaseController.ts, src/utils/validation.ts_\n  - _Requirements: 4.2, 4.3_\n  - _Prompt: Role: Full-stack Developer with expertise in API development and validation | Task: Implement CRUD endpoints following requirements 4.2 and 4.3, extending BaseController patterns and using validation utilities from src/utils/validation.ts | Restrictions: Must validate all inputs, follow existing controller patterns, ensure proper HTTP status codes and responses | Success: All CRUD operations work correctly, request validation prevents invalid data, integration tests pass and cover all endpoints_\n\n- [ ] 5. Add frontend components\n  - Plan component architecture\n  - _Leverage: src/components/BaseComponent.tsx, src/styles/theme.ts_\n  - _Requirements: 5.0_\n  - _Prompt: Role: Frontend Architect with expertise in React component design and architecture | Task: Plan comprehensive component architecture following requirement 5.0, leveraging base patterns from src/components/BaseComponent.tsx and theme system from src/styles/theme.ts | Restrictions: Must follow existing component patterns, maintain design system consistency, ensure component reusability | Success: Architecture is well-planned and documented, components are properly organized, follows existing patterns and theme system_\n\n- [ ] 5.1 Create base UI components\n  - Set up component structure\n  - Implement reusable components\n  - Add styling and theming\n  - _Leverage: src/components/BaseComponent.tsx, src/styles/theme.ts_\n  - _Requirements: 5.1_\n  - _Prompt: Role: Frontend Developer specializing in React and component architecture | Task: Create reusable UI components following requirement 5.1, extending BaseComponent patterns and using existing theme system from src/styles/theme.ts | Restrictions: Must use existing theme variables, follow component composition patterns, ensure accessibility compliance | Success: Components are reusable and properly themed, follow existing architecture, accessible and responsive_\n\n- [ ] 5.2 Implement feature-specific components\n  - Create feature components\n  - Add state management\n  - Connect to API endpoints\n  - _Leverage: src/hooks/useApi.ts, src/components/BaseComponent.tsx_\n  - _Requirements: 5.2, 5.3_\n  - _Prompt: Role: React Developer with expertise in state management and API integration | Task: Implement feature-specific components following requirements 5.2 and 5.3, using API hooks from src/hooks/useApi.ts and extending BaseComponent patterns | Restrictions: Must use existing state management patterns, handle loading and error states properly, maintain component performance | Success: Components are fully functional with proper state management, API integration works smoothly, user experience is responsive and intuitive_\n\n- [ ] 6. Integration and testing\n  - Plan integration approach\n  - _Leverage: src/utils/integrationUtils.ts, tests/helpers/testUtils.ts_\n  - _Requirements: 6.0_\n  - _Prompt: Role: Integration Engineer with expertise in system integration and testing strategies | Task: Plan comprehensive integration approach following requirement 6.0, leveraging integration utilities from src/utils/integrationUtils.ts and test helpers | Restrictions: Must consider all system components, ensure proper test coverage, maintain integration test reliability | Success: Integration plan is comprehensive and feasible, all system components work together correctly, integration points are well-tested_\n\n- [ ] 6.1 Write end-to-end tests\n  - Set up E2E testing framework\n  - Write user journey tests\n  - Add test automation\n  - _Leverage: tests/helpers/testUtils.ts, tests/fixtures/data.ts_\n  - _Requirements: All_\n  - _Prompt: Role: QA Automation Engineer with expertise in E2E testing and test frameworks like Cypress or Playwright | Task: Implement comprehensive end-to-end tests covering all requirements, setting up testing framework and user journey tests using test utilities and fixtures | Restrictions: Must test real user workflows, ensure tests are maintainable and reliable, do not test implementation details | Success: E2E tests cover all critical user journeys, tests run reliably in CI/CD pipeline, user experience is validated from end-to-end_\n\n- [ ] 6.2 Final integration and cleanup\n  - Integrate all components\n  - Fix any integration issues\n  - Clean up code and documentation\n  - _Leverage: src/utils/cleanup.ts, docs/templates/_\n  - _Requirements: All_\n  - _Prompt: Role: Senior Developer with expertise in code quality and system integration | Task: Complete final integration of all components and perform comprehensive cleanup covering all requirements, using cleanup utilities and documentation templates | Restrictions: Must not break existing functionality, ensure code quality standards are met, maintain documentation consistency | Success: All components are fully integrated and working together, code is clean and well-documented, system meets all requirements and quality standards_\n",
      "source": "server",
      "path": "/home/laimk/git/spec-context-mcp/dist/templates/tasks-template.md"
    }
  },
  "disciplineMode": "full",
  "dispatch": {
    "implementerCli": "codex exec --full-auto",
    "reviewerCli": "codex exec --sandbox read-only",
    "implementerConfigured": true,
    "reviewerConfigured": true
  },
  "dashboardUrl": "http://localhost:3000",
  "dashboardAvailable": true
}